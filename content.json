{"meta":{"title":"仰望星空,脚踏实地","subtitle":"Starry Don's BLOG","description":"","author":"Starry Don","url":"https://dllmayday.github.io","root":"/"},"pages":[{"title":"博客日志","date":"2025-08-18T16:00:00.000Z","updated":"2025-08-19T09:58:06.742Z","comments":true,"path":"blog-log.html","permalink":"https://dllmayday.github.io/blog-log.html","excerpt":"","text":"fetch('/content.json').then(r=>r.json()).then(data=>{ let html = data.posts.map(p=>`${p.title} - ${p.date.slice(0,10)}`).join(''); document.getElementById('post-log').innerHTML = html; });"},{"title":"在线资料","date":"2025-08-19T06:40:00.000Z","updated":"2025-08-19T09:56:21.801Z","comments":true,"path":"OnlineResources/index.html","permalink":"https://dllmayday.github.io/OnlineResources/index.html","excerpt":"","text":"Qt ROS CAN Matlab 面试题 Qt 霍亚飞 - Qt Creator 快速入门（第三版）-北京航空航天大学出版社 (2017) QmlBook 中文版 (Z-lib.io).epub ROS ROS入门教程 Mastering ROS for Robotics Programming Programming Robots with ROS 第1讲：认识ROS_课件 ROS介绍.pptx CAN CANoe 培训文档 2020 Matlab matlab教程 面试题 CC++面试题 Linux面试题 MySQL面试题 Shell面试题 SQL面试题 function showTab(tabId) { // 隐藏所有内容 document.querySelectorAll('.tab-content').forEach(div => { div.style.display = 'none'; }); // 显示选中的分类内容 document.getElementById(tabId).style.display = 'block'; } /* 隐藏原生 radio */ .tab-label input[type=\"radio\"] { appearance: none; -webkit-appearance: none; -moz-appearance: none; margin-right: 8px; width: 14px; height: 14px; border: 2px solid #aaa; border-radius: 4px; vertical-align: middle; cursor: pointer; position: relative; } /* 选中时高亮 */ .tab-label input[type=\"radio\"]:checked { border-color: #0078d7; background-color: #0078d7; } /* 鼠标悬停时轻微变化 */ .tab-label:hover { background: #f5f5f5; cursor: pointer; border-radius: 4px; } /* 整个选中的分类行高亮 */ .tab-label input[type=\"radio\"]:checked + span, .tab-label:has(input[type=\"radio\"]:checked) { background: #e6f0ff; border-radius: 4px; pad }"},{"title":"站点导航","date":"2024-02-21T06:40:49.000Z","updated":"2025-08-18T09:22:36.249Z","comments":true,"path":"SiteNav/index.html","permalink":"https://dllmayday.github.io/SiteNav/index.html","excerpt":"系列教程w3cschool | 菜鸟教程 | CV系列教程 (showmeai.tech)Codecademy | edX | Udemy | Coursera | aGupieWare | Khan Academy 技术社区GitHub | SourceForge | stackoverflow.com&#x2F; | codeproject | 码云 | CSDN | 开源中国 | 博客园 | 掘金 C++标准参考网站cppreference.com | cplusplus.com | isocpp.org | learncpp.com| C++之父Bjarne Stroustrup的主页 C++ 在线代码编译运行验证cpp.sh","text":"系列教程w3cschool | 菜鸟教程 | CV系列教程 (showmeai.tech)Codecademy | edX | Udemy | Coursera | aGupieWare | Khan Academy 技术社区GitHub | SourceForge | stackoverflow.com&#x2F; | codeproject | 码云 | CSDN | 开源中国 | 博客园 | 掘金 C++标准参考网站cppreference.com | cplusplus.com | isocpp.org | learncpp.com| C++之父Bjarne Stroustrup的主页 C++ 在线代码编译运行验证cpp.sh 图形图像处理Shader着色器分享 OpenGL教程LearnOpenGL | LearnOpenGL-CN |Joe’s Blog个人站点 WebGL教程WebGL接口参考 - MDN (mozilla.org) | WebGL Fundamentals 渲染引擎Godot Docs – 4.2 branch — Godot Engine (stable) documentation in English | gameplay3d - free 2D&#x2F;3D game frameworkPanda3D - Open Source Framework for 3D Rendering &amp; Games |QOpenGLWidget Class - Qt OpenGL 3D模型下载sketchfab| cgtrader | glTF-Sample-Models | zhuanlan.zhihu HDRIs环境贴图下载polyhaven | hdri-haven | hdrmaps |hdri-skies | openfootage | texturer X windowX.Org | tronche.com&#x2F;gui&#x2F;x&#x2F;xlib&#x2F; 嵌入式QNX使用手册 AI会话Copilot - Microsoft | ChatGPT- OpenAI(outlook) | Bard - Google | 文心一言 - Baidu | Kimi AI绘画SD |Midjourneyai | AIGC Nav 数字图书馆idata | z-lib | libGenzh&#x2F; | sci-hub | researchgate|小木虫 |虫部落 矢量素材库阿里矢量素材库 | iconscout | Freepik |FlatIcon |ICONS8 | iconarchive | pixcap 杂七杂八filehorse - app download JSFiddle-HTML&#x2F;CSS&#x2F;JS效果预览V2free(foxmail) 版权信息"},{"title":"技术分享","date":"2024-02-05T03:06:49.000Z","updated":"2025-08-18T09:22:36.249Z","comments":true,"path":"Technology/index.html","permalink":"https://dllmayday.github.io/Technology/index.html","excerpt":"","text":""},{"title":"关于","date":"2024-02-05T01:44:46.000Z","updated":"2025-08-19T06:09:58.982Z","comments":true,"path":"about/index.html","permalink":"https://dllmayday.github.io/about/index.html","excerpt":"","text":"关于本站 创建本站的目的用于博主记录工作中的问题解决办法，技术学习教程、经验总结，以及生活随笔感悟等。 从事多年开发工作一直没有建立自己的博客。总是零散的记录在了CSDN，简书，OneNote等各处。没有形成整理。未来将全部迁移到本站。 关于博主 GIS专业走上了编程开发之路，做过GIS平台,做过遥感卫星处理，做过BIM建模，做过车载环视系统，做过国产操作系统等。未来还可能做什么待续... 个人账号: E-mail：dllmayday@163.com 下面是本站的相关信息： 博客统计：访问量： 博客日志"},{"title":"生活随笔","date":"2024-02-05T03:14:06.000Z","updated":"2025-08-18T09:22:36.292Z","comments":true,"path":"lifelive/index.html","permalink":"https://dllmayday.github.io/lifelive/index.html","excerpt":"","text":""}],"posts":[{"title":"sd-bus-demo","slug":"dbus/sd-bus-demo","date":"2025-02-14T09:08:12.000Z","updated":"2025-08-18T09:22:36.254Z","comments":true,"path":"2025/02/14/dbus/sd-bus-demo/","permalink":"https://dllmayday.github.io/2025/02/14/dbus/sd-bus-demo/","excerpt":"systemd&#x2F;sd-bus 实现一个简单的服务端代码。sd-bus接口","text":"systemd&#x2F;sd-bus 实现一个简单的服务端代码。sd-bus接口 实现 定义 D-Bus 接口首先，定义一个 D-Bus 接口，包含以下方法：EnterCustomMode(): 进入定制模式。ExitCustomMode(): 退出定制模式。Heartbeat(): 客户端定时调用的心跳函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;systemd/sd-bus.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#define DBUS_INTERFACE &quot;com.example.CustomMode&quot;#define DBUS_OBJECT_PATH &quot;/com/example/CustomMode&quot;static int custom_mode = 0;static time_t last_heartbeat = 0;static int method_enter_custom_mode(sd_bus_message *m, void *userdata, sd_bus_error *ret_error) &#123; custom_mode = 1; last_heartbeat = time(NULL); return sd_bus_reply_method_return(m, &quot;&quot;);&#125;static int method_exit_custom_mode(sd_bus_message *m, void *userdata, sd_bus_error *ret_error) &#123; custom_mode = 0; return sd_bus_reply_method_return(m, &quot;&quot;);&#125;static int method_heartbeat(sd_bus_message *m, void *userdata, sd_bus_error *ret_error) &#123; last_heartbeat = time(NULL); return sd_bus_reply_method_return(m, &quot;&quot;);&#125;static const sd_bus_vtable custom_mode_vtable[] = &#123; SD_BUS_VTABLE_START(0), SD_BUS_METHOD(&quot;EnterCustomMode&quot;, &quot;&quot;, &quot;&quot;, method_enter_custom_mode, SD_BUS_VTABLE_UNPRIVILEGED), SD_BUS_METHOD(&quot;ExitCustomMode&quot;, &quot;&quot;, &quot;&quot;, method_exit_custom_mode, SD_BUS_VTABLE_UNPRIVILEGED), SD_BUS_METHOD(&quot;Heartbeat&quot;, &quot;&quot;, &quot;&quot;, method_heartbeat, SD_BUS_VTABLE_UNPRIVILEGED), SD_BUS_VTABLE_END&#125;;int main(int argc, char *argv[]) &#123; sd_bus *bus = NULL; sd_bus_slot *slot = NULL; int r; r = sd_bus_open_system(&amp;bus); if (r &lt; 0) &#123; fprintf(stderr, &quot;Failed to connect to system bus: %s\\n&quot;, strerror(-r)); goto finish; &#125; r = sd_bus_add_object_vtable(bus, &amp;slot, DBUS_OBJECT_PATH, DBUS_INTERFACE, custom_mode_vtable, NULL); if (r &lt; 0) &#123; fprintf(stderr, &quot;Failed to add object vtable: %s\\n&quot;, strerror(-r)); goto finish; &#125; r = sd_bus_request_name(bus, DBUS_INTERFACE, 0); if (r &lt; 0) &#123; fprintf(stderr, &quot;Failed to acquire service name: %s\\n&quot;, strerror(-r)); goto finish; &#125; while (1) &#123; r = sd_bus_process(bus, NULL); if (r &lt; 0) &#123; fprintf(stderr, &quot;Failed to process bus: %s\\n&quot;, strerror(-r)); goto finish; &#125; if (r &gt; 0) continue; r = sd_bus_wait(bus, (uint64_t) 1000000); // 1 second timeout if (r &lt; 0) &#123; fprintf(stderr, &quot;Failed to wait on bus: %s\\n&quot;, strerror(-r)); goto finish; &#125; // Check heartbeat timeout if (custom_mode &amp;&amp; (time(NULL) - last_heartbeat) &gt; 10) &#123; custom_mode = 0; printf(&quot;Heartbeat timeout, exiting custom mode.\\n&quot;); &#125; &#125;finish: sd_bus_slot_unref(slot); sd_bus_unref(bus); return r &lt; 0 ? EXIT_FAILURE : EXIT_SUCCESS;&#125; 编译1gcc -o sdbus-demo demo.c -lsystemd 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"dbus","slug":"技术分享/dbus","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/dbus/"}],"tags":[{"name":"dbus","slug":"dbus","permalink":"https://dllmayday.github.io/tags/dbus/"}]},{"title":"cmake常见编译选项","slug":"cmake/cmakeinnerbuildoption","date":"2025-02-14T08:46:10.000Z","updated":"2025-08-18T09:22:36.252Z","comments":true,"path":"2025/02/14/cmake/cmakeinnerbuildoption/","permalink":"https://dllmayday.github.io/2025/02/14/cmake/cmakeinnerbuildoption/","excerpt":"CMake 提供了一些内置的编译选项和变量，用于控制编译过程、优化构建配置、设置安装路径等。以下是一些常见的 CMake 内置编译选项： 1. CMAKE_BUILD_TYPE","text":"CMake 提供了一些内置的编译选项和变量，用于控制编译过程、优化构建配置、设置安装路径等。以下是一些常见的 CMake 内置编译选项： 1. CMAKE_BUILD_TYPE 设置构建类型，这决定了生成的编译选项和优化级别。常见的值有： Debug：调试模式，生成符号文件以便调试。 Release：发布模式，进行优化，去除调试信息。 RelWithDebInfo：带调试信息的发布模式，包含优化和调试信息。 MinSizeRel：优化生成最小的可执行文件。 1cmake -DCMAKE_BUILD_TYPE=Release .. 2. CMAKE_CXX_FLAGS &#x2F; CMAKE_C_FLAGS 分别为 C++ 和 C 编译器设置额外的编译标志。例如，启用 -Wall 警告或其他编译器特性： 1cmake -DCMAKE_CXX_FLAGS=&quot;-Wall -O2&quot; .. 3. CMAKE_CXX_COMPILER &#x2F; CMAKE_C_COMPILER 指定用于 C++ 和 C 编译的编译器路径。如果不指定，CMake 会使用系统默认的编译器。 1cmake -DCMAKE_CXX_COMPILER=/path/to/g++ .. 4. CMAKE_INSTALL_PREFIX 设置 make install 时的安装路径。默认情况下，安装路径是 /usr/local（或 Windows 上的 C:/Program Files/）。通过 -DCMAKE_INSTALL_PREFIX 可以自定义安装目录。 1cmake -DCMAKE_INSTALL_PREFIX=/path/to/install .. 5. CMAKE_VERBOSE_MAKEFILE 启用或禁用生成的 Makefile 的详细输出。设置为 TRUE 会输出详细的编译和链接命令。 1cmake -DCMAKE_VERBOSE_MAKEFILE=TRUE .. 6. CMAKE_EXPORT_COMPILE_COMMANDS 设置为 TRUE 时，CMake 会生成 compile_commands.json 文件，包含项目的编译命令，通常用于集成开发环境（IDE）或工具，如 clang-tidy、clangd 等。 1cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=YES .. 7. CMAKE_TOOLCHAIN_FILE 使用指定的工具链文件来设置交叉编译的环境或使用不同的编译器。 1cmake -DCMAKE_TOOLCHAIN_FILE=/path/to/toolchain.cmake .. 8. CMAKE_PREFIX_PATH 指定 CMake 查找外部包的路径。例如，告诉 CMake 在特定路径中查找第三方库或依赖。 1cmake -DCMAKE_PREFIX_PATH=/path/to/libraries .. 9. CMAKE_INSTALL_RPATH 设置动态库查找路径（rpath）的安装路径。常用于指定安装后可执行文件查找动态库的路径。 1cmake -DCMAKE_INSTALL_RPATH=/path/to/libs .. 10. CMAKE_OSX_ARCHITECTURES 在 macOS 上指定构建架构（如 x86_64 或 arm64）。用于构建多个架构的二进制文件。 1cmake -DCMAKE_OSX_ARCHITECTURES=&quot;x86_64;arm64&quot; .. 11. CMAKE_BUILD_PARALLEL_LEVEL 控制并行构建的数量。默认情况下，CMake 会根据系统的核心数自动选择并行构建的级别，可以通过该选项覆盖。 1cmake -DCMAKE_BUILD_PARALLEL_LEVEL=4 .. 12. CMAKE_DISABLE_FIND_PACKAGE_&lt;PACKAGE_NAME&gt; 禁用查找特定包的功能。例如，如果你不想让 CMake 查找 OpenGL 包，可以使用： 1cmake -DCMAKE_DISABLE_FIND_PACKAGE_OpenGL=TRUE .. 13. CMAKE_EXPORT_NO_PACKAGE_REGISTRY 禁用将包信息写入包注册表。如果你不希望 CMake 在生成过程中修改包注册表，可以设置此选项： 1cmake -DCMAKE_EXPORT_NO_PACKAGE_REGISTRY=TRUE .. 14. CMAKE_SKIP_INSTALL_RPATH 跳过设置安装后的 rpath，通常用于控制库的路径查找行为。 1cmake -DCMAKE_SKIP_INSTALL_RPATH=TRUE .. 15. CMAKE_PREFIX_PATH 用于添加 CMake 搜索库、包的路径。例如，如果依赖的库不在系统标准路径下，可以指定一个路径： 1cmake -DCMAKE_PREFIX_PATH=/path/to/special/libs .. 16. CMAKE_FIND_FRAMEWORK 在 macOS 上使用这个选项可以控制是否查找 Frameworks： 1cmake -DCMAKE_FIND_FRAMEWORK=LAST .. 这些是 CMake 中最常见的内置编译选项，你可以根据项目的具体需求来传递不同的参数和选项。你是否正在配置某个特定的项目？如果有任何问题或需要更多细节，随时告诉我！ 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Cmake","slug":"技术分享/Cmake","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Cmake/"}],"tags":[{"name":"Cmake","slug":"Cmake","permalink":"https://dllmayday.github.io/tags/Cmake/"}]},{"title":"virt-manager虚拟机安装","slug":"virt-manager/virt-manager","date":"2025-02-14T07:31:07.000Z","updated":"2025-08-18T09:22:36.264Z","comments":true,"path":"2025/02/14/virt-manager/virt-manager/","permalink":"https://dllmayday.github.io/2025/02/14/virt-manager/virt-manager/","excerpt":"virt-manager简介virt-manager 应用程序是一个桌面用户界面，用于通过 libvirt 管理虚拟机。它主要针对 KVM VM，但也管理 Xen 和 LXC（Linux 容器）。它提供了正在运行的域的摘要视图、它们的实时性能和资源利用率统计信息。向导支持创建新域，以及配置和调整域的资源分配和虚拟硬件。嵌入式 VNC 和 SPICE 客户端查看器为来宾域提供了完整的图形控制台 安装使用","text":"virt-manager简介virt-manager 应用程序是一个桌面用户界面，用于通过 libvirt 管理虚拟机。它主要针对 KVM VM，但也管理 Xen 和 LXC（Linux 容器）。它提供了正在运行的域的摘要视图、它们的实时性能和资源利用率统计信息。向导支持创建新域，以及配置和调整域的资源分配和虚拟硬件。嵌入式 VNC 和 SPICE 客户端查看器为来宾域提供了完整的图形控制台 安装使用 1.检查CPU虚拟化支持首先，确认你的CPU支持硬件虚拟化技术（Intel VT或AMD-V）。可以通过执行以下命令来检查 1egrep -c &#x27;(vmx|svm)&#x27;/proc/cpuinfo 2.安装KVM和QEMU在确认硬件支持虚拟化之后，确保KVM和QEMU已经安装。可以通过以下命令安装： 12sudo apt-get update sudo apt-get installqemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virt-manager 这些命令会安装KVM，QEMU，以及其他必要的虚拟化管理工具和库。3.启动和检查Libvirt服务状态安装完成后，需要确保 libvirtd服务（或在某些系统中叫 libvirt-bin）正在运行。使用以下命令检查服务状态： 123sudosystemctl status libvirtdsudosystemctl start libvirtdsudo systemctl enable libvirtd 4.配置用户权限确保你的用户账号被加入到 libvirt和 kvm用户组，允许无密码管理虚拟机：检查用户是否属于 libvirt 组： 1groups 如果没有，使用以下命令将当前用户添加到 libvirt 组 123sudo usermod -a -G libvirt $(whoami) sudo usermod -a -Gkvm $(whoami) 然后注销并重新登录，或者运行以下命令来更新组信息 1newgrp libvirt libvirt 报错Failed toconnect to socket to ‘&#x2F;var&#x2F;run&#x2F;libvirt&#x2F;libvirt-sock’:Permission dinied解决方案这个错误提示说明libvirt 无法连接到 Unix 套接字&#x2F;var&#x2F;run&#x2F;libvirt&#x2F;libvirt-sock，可能是由于权限问题导致的。你可以尝试以下几种方法来解决问题：（1）检查用户权限 如上第四步（2）检查套接字文件权限检查&#x2F;var&#x2F;run&#x2F;libvirt&#x2F;libvirt-sock 的权限，确保当前用户有读取和写入权限： 1ls-l/var/run/libvirt/libvirt-sock 如果权限不正确，可以通过以下命令修改： 1sudo chmod 666 /var/run/libvirt/libvirt-sock 5.安装镜像点击添加连接，可按照默认配置，点击连接后确保连接成功 选择新建虚拟机，本地安装介质后选择虚拟机镜像开始安装 参考资料：https://www.8kiz.cn/archives/16478.htmlhttps://www.cnxclm.com/read-3204-1.htmlhttps://zhuanlan.zhihu.com/p/83331819 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"virtual-machine","slug":"技术分享/virtual-machine","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/virtual-machine/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://dllmayday.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"docker使用教程","slug":"dockerguide","date":"2024-04-28T09:10:04.000Z","updated":"2025-08-18T09:22:36.255Z","comments":true,"path":"2024/04/28/dockerguide/","permalink":"https://dllmayday.github.io/2024/04/28/dockerguide/","excerpt":"官方地址：Docker ubuntu20.04 安装步骤 参考地址","text":"官方地址：Docker ubuntu20.04 安装步骤 参考地址 设置apt 仓库安装 12345678910111213 # Add Docker&#x27;s official GPG key:sudo apt-get updatesudo apt-get install ca-certificates curlsudo install -m 0755 -d /etc/apt/keyringssudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.ascsudo chmod a+r /etc/apt/keyrings/docker.asc# Add the repository to Apt sources:echo \\ &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\ $(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;) stable&quot; | \\ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt-get update 安装 Docker 软件包 1sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 通过运行镜像来验证Docker Engine安装是否成功 hello-world 1$ sudo docker run hello-world 终端打印显示如下，则安装成功 123456789101112131415161718192021222324252627 Unable to find image &#x27;hello-world:latest&#x27; locallylatest: Pulling from library/hello-worldc1ec31eb5944: Pull complete Digest: sha256:a26bff933ddc26d5cdf7faa98b4ae1e3ec20c4985e6f87ac0973052224d24302Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ Docker 安装拉取Ubuntu镜像 查看可用的 Ubuntu 版本 访问 Ubuntu 镜像库地址： https://hub.docker.com/_/ubuntu?tab=tags&amp;page=1。可以通过 Sort by 查看其他版本的 Ubuntu。默认是最新版本 ubuntu:latest 。2. 拉取最新版的 Ubuntu 镜像 1$ docker pull ubuntu 或者： 1$ docker pull ubuntu:latest 拉取指定版本Ubuntu镜像 1$ docker pull ubuntu:20.04 查看本地镜像 4. 删除镜像 1docker rmi &lt;容器名&gt; Docker 容器使用 创建容器 1$ docker run -it --name my-ubuntu-container ubuntu /bin/bash 这里，-it 参数让Docker提供一个交互式终端，–name my-ubuntu-container 给你的容器命名为 my-ubuntu-container。 查看所有的容器 1$ docker ps -a 启动容器 12$ docker start &lt;容器ID&gt; #启动已停止容器 $ docker restart &lt;容器 ID&gt; #重启 后台启动运行1$ docker run -itd --name ubuntu-test ubuntu /bin/bash 停止容器 1$ docker stop &lt;容器 ID&gt; 进入容器 12docker attach &lt;容器 ID&gt; #终端退出后容器停止docker exec -it &lt;容器 ID&gt; /bin/bash #终端退出，容器不会停止 导入导出容器 123$ docker export &lt;容器 ID&gt; &gt; ubuntu.tar #导出容器# 如果导出的是容器文件系统，可以创建一个新容器并从tar文件中导入文件系统：docker import my_container.tar my_container_image 保存容器镜像：如果你想要迁移整个容器，包括其状态，你需要先创建一个镜像，然后保存为tar文件。 1234docker commit my_container my_container_imagedocker save my_container_image &gt; my_container_image.tar# 在目标机器上，使用docker load命令加载镜像。docker load &lt; my_container_image.tar 移除容器1$ docker rm &lt;容器ID&gt; 组管理创建docker group12$ groups #查看当前组，若不存在docker组则用如下命令创建docker组$ sudo groupadd docker 增加当前系统用户到docker组 **这一步设置非常重要，否则当前用户下执行命令行需要加sudo，VS Code配置Dock访问管理无法获取权限！！！** 1sudo usermod -aG docker $USER 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Docker","slug":"技术分享/Docker","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://dllmayday.github.io/tags/Docker/"}]},{"title":"GDB调试","slug":"GDB","date":"2024-02-21T07:14:50.000Z","updated":"2025-08-18T09:22:36.250Z","comments":true,"path":"2024/02/21/GDB/","permalink":"https://dllmayday.github.io/2024/02/21/GDB/","excerpt":"##1.Debugged program settings 12set args [Arguments]show args ##2.break commandCreates a breakpoint at a specified line, address or function.","text":"##1.Debugged program settings 12set args [Arguments]show args ##2.break commandCreates a breakpoint at a specified line, address or function. ###Syntax 123456789breakbbreak [Function Name]break [File Name]:[Line Number]break [Line Number]break *[Address]break [...] if [Condition]break [...] thread [Thread-id]b [...] ###ExamplesUsing function name: 123(gdb) b mainBreakpoint 1 at 0x401395: file 0.cpp, line 4.(gdb) Using function address: 12345(gdb) info address mainSymbol &quot;main(int, char**)&quot; is a function at address 0x40138c.(gdb) break *0x40138cBreakpoint 2 at 0x40138c: file 0.cpp, line 4.(gdb) Using file name and line number: 12345(gdb) info line mainLine 4 of &quot;0.cpp&quot; starts at address 0x40138c &lt;main(int, char**)&gt;and ends at 0x401395 &lt;main(int, char**)+9&gt;.(gdb) break 0.cpp:4Breakpoint 3 at 0x401395: file 0.cpp, line 4. Using line number only: 123456789(gdb) info sourceCurrent source file is 0.cppCompilation directory is C:\\MinGW\\binLocated in c:\\mingw\\bin\\0.cppSource language is c++.Compiled with DWARF 2 debugging format.Does not include preprocessor macro info.(gdb) break 4Breakpoint 4 at 0x40138c: file 0.cpp, line 4. #3. Shared library commands##info sharedlibrary command 12info sharedlibraryinfo share ##set solib-search-path command 12set solib-search-path [Directories]show solib-search-path ##set sysroot command 12345set sysroot [Directory]set sysroot remote:/set sysroot remote:[Remote directory]set solib-absolute-prefix [Directory]show sysroot 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Debug","slug":"技术分享/Debug","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Debug/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://dllmayday.github.io/tags/Debug/"}]},{"title":"MDC610交叉编译","slug":"MDC610","date":"2024-02-21T07:14:50.000Z","updated":"2025-08-18T09:22:36.250Z","comments":true,"path":"2024/02/21/MDC610/","permalink":"https://dllmayday.github.io/2024/02/21/MDC610/","excerpt":"MDC610交叉编译","text":"MDC610交叉编译 1.准备工作环境准备| 系统架构 | X86_64 || — | — || 操作系统 | Ubuntu 18.04及以上版本 须知： MDC平台工具链仅支持Ubuntu 18.04版本。 | 获取软件包| 软件包 | 说明 || — | — || MDC_SDK-{version}.tar.gz | MDC二次开发包，包含gcc和clang编译器、编译框架和平台ARXML文件。 || MDC_SDK-{version}_llvm.tar.gz | 用于安装llvm编译器。 || MDC_AOS_rpmlist-{version}.tar.gz | 用于在交叉编译环境中安装第三方库。 || MDC_AOS_rpmlist-*{version}_*llvm.tar.gz | 用于在安装了llvm的编译环境中安装第三方库。 || MDC-{version}.tar.gz | MDC产品包，包含AP平台包，OS镜像，以及MCU、CPLD、BIOS等固件包。 | 2.搭建交叉编译环境 在开发环境中，以普通用户打开终端。 进入SDK包（MDC_SDK-{version}.tar.gz）所在目录，并将SDK包解压至指定目录。 执行命令sudo mkdir -p &#x2F;usr&#x2F;local，创建目录“&#x2F;usr&#x2F;local”。 执行命令sudo tar -xf MDC_SDK-{version}.tar.gz -C &#x2F;usr&#x2F;local，将SDK安装包解压至“&#x2F;usr&#x2F;local”目录下，解压即安装。 解压得到的“mdc_sdk”目录说明如下： | 目录 | 说明 || — | — || dp_gea | 存在GEA系统环境所需交叉编译器gcc、g++等。 || manifest | 存在MDC平台的ARXML文件，Sample等。 || env_check.py | 用于检查Ubuntu、cmake和make版本是否符合要求的脚本。 | 确认Ubuntu系统版本为18.04，且已安装满足版本要求的构建&#x2F;调试工具cmake（3.10.2及以上）和make（4.1及以上）。 在“&#x2F;usr&#x2F;local&#x2F;mdc_sdk”目录下执行校验版本号的脚本命令**.&#x2F;env_check.py**，回显示例如下，若提示不符合版本要求，请根据要求安装或升级至匹配版本。 [INFO]cmake version is **OK**, the current version is 3.10.2 [INFO]make version is **OK**, the current version is 4.1 [INFO]Ubuntu version is **OK**, the current version is Ubuntu 18.04.6 LTS \\n \\l 执行如下命令，配置环境变量。 export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;mdc_sdk&#x2F;dp_gea&#x2F;mdc_cross_compiler&#x2F;bin:$PATH 依次执行如下命令，确认环境变量配置正确。 which aarch64-target-linux-gnu-gcc，通过回显确认gcc的安装路径，即步骤4中的安装路径。 /usr/local/mdc_sdk/dp_gea/mdc_cross_compiler/bin/aarch64-target-linux-gnu-gcc **which aarch64-target-linux-gnu-g++**，通过回显确认g++的安装路径，即步骤4中的安装路径。 /usr/local/mdc_sdk/dp_gea/mdc_cross_compiler/bin/aarch64-target-linux-gnu-g++ 3.构建应用下文以编译helloworld.c文件为例，介绍代码的编译和运行步骤。 编写代码，即编辑helloworld.c文件。代码示例如下： 1234567#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello World!\\n&quot;); return 0;&#125; 2.在开发环境中执行命令export CC&#x3D;aarch64-target-linux-gnu-gcc，指定编译器3.创建并编写构建文件（Makefile）。 1234src_file=helloworld.celf_file=helloworldall: $&#123;CC&#125; -I $&#123;SYSROOT&#125;/usr/include -L $&#123;SYSROOT&#125;/usr/lib64 $&#123;src_file&#125; -o $&#123;elf_file&#125; 编译helloworld.c文件。 进入helloworld.c文件所在目录，依次执行如下命令： **export SYSROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;mdc_sdk&#x2F;dp_gea&#x2F;mdc_cross_compiler&#x2F;sysroot&#x2F;**，指定编译目录。 make，开始编译。 在“helloworld.c”文件所在目录执行命令ls，若返回结果含有可执行文件（helloworld），表示编译成功。 以SSH连接方式登录MDC系统环境（用户名和密码请参考《调测指南》的“登录操作系统”章节），并在AOS运行环境中运行helloworld。 总结交叉编译脚本，可直接编译cmake工程如下:(1)build_mdc.sh 12345678rm -rf ./buildmkdir buildcd ./buildcmake -DCMAKE_SYSTEM_PROCESSOR=&quot;aarch64&quot; \\ -DCMAKE_TOOLCHAIN_FILE=/usr/local/mdc_sdk/dp_gea/toolchain.cmake \\ ..make -j8 (2)toolchain.cmake 123456789101112131415161718192021222324252627get_filename_component(TOOLCHAIN_FILE_PATH &quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;&quot; PATH)set(SCFI_SDK_TYPE dp_gea)set(CMAKE_SYSTEM_NAME Linux)set(CMAKE_SYSTEM_PROCESSOR arm)set(SCFI_REPO $&#123;TOOLCHAIN_FILE_PATH&#125;)set(SCFI_MDC_SDK $&#123;SCFI_REPO&#125;/mdc_cross_compiler/sysroot/usr)set(SCFI_USER_SDK $&#123;SCFI_REPO&#125;/user_repo)set(SCFI_CROSS_COMPILE $&#123;SCFI_REPO&#125;/mdc_cross_compiler/bin)set(SCFI_MDC_SDK_CMAKE $&#123;SCFI_MDC_SDK&#125;/lib/cmake)set(SCFI_USER_SDK_CMAKE $&#123;SCFI_USER_SDK&#125;/lib/cmake)file(RELATIVE_PATH SCFI_REPO_RELATIVE_MDC_CMAKE $&#123;SCFI_MDC_SDK_CMAKE&#125; $&#123;SCFI_REPO&#125;)file(RELATIVE_PATH SCFI_REPO_RELATIVE_USER_CMAKE $&#123;SCFI_USER_SDK_CMAKE&#125; $&#123;SCFI_REPO&#125;)file(RELATIVE_PATH SCFI_MDC_RELATIVE_USER_SDK $&#123;SCFI_USER_SDK&#125; $&#123;SCFI_MDC_SDK&#125;)file(RELATIVE_PATH SCFI_USER_RELATIVE_MDC_SDK $&#123;SCFI_MDC_SDK&#125; $&#123;SCFI_USER_SDK&#125;)set(ara-exec_DIR $&#123;SCFI_MDC_SDK_CMAKE&#125;/exec/)set(CMAKE_C_COMPILER $&#123;SCFI_CROSS_COMPILE&#125;/aarch64-target-linux-gnu-gcc)set(CMAKE_CXX_COMPILER $&#123;SCFI_CROSS_COMPILE&#125;/aarch64-target-linux-gnu-g++)set(CMAKE_FIND_ROOT_PATH $&#123;SCFI_USER_SDK&#125; $&#123;SCFI_MDC_SDK&#125; $&#123;CMAKE_FIND_ROOT_PATH&#125;)set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY) 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"交叉编译","slug":"技术分享/交叉编译","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"交叉编译","slug":"交叉编译","permalink":"https://dllmayday.github.io/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"}]},{"title":"QNX下位机coredump调试","slug":"QNXcoredump","date":"2024-02-21T07:14:50.000Z","updated":"2025-08-18T09:22:36.251Z","comments":true,"path":"2024/02/21/QNXcoredump/","permalink":"https://dllmayday.github.io/2024/02/21/QNXcoredump/","excerpt":"引用地址##什么是coredump？ 通常情况下coredmp包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息等。可以理解为把程序工作的当前状态存储成一个文件。许多程序和操作系统出错时会自动生成一个core文件##如何使用coredump？coredump可以用在很多场合，使用Linux或者solaris的人可能都有过这种经历，系统在跑一些压力测试或者系统负载一大的话，系统就hang住了或者干脆system panic.这时唯一能帮助你分析和解决问题的就是coredump了。现在很多应该程序出错时也会出现coredump.","text":"引用地址##什么是coredump？ 通常情况下coredmp包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息等。可以理解为把程序工作的当前状态存储成一个文件。许多程序和操作系统出错时会自动生成一个core文件##如何使用coredump？coredump可以用在很多场合，使用Linux或者solaris的人可能都有过这种经历，系统在跑一些压力测试或者系统负载一大的话，系统就hang住了或者干脆system panic.这时唯一能帮助你分析和解决问题的就是coredump了。现在很多应该程序出错时也会出现coredump. ##分析coredump的工具现在大部分类unix操作系统都提供了分析core文件的工具，比如 GNU Binutils Binary File Descriptor library (BFD),GNU Debugger (gdb），mdb等。coredump的文件格式类unix操作系统中使用efi格式保存coredump文件。造成程序coredump的原因很多，这里根据以往的经验总结一下： 内存访问越界 a) 由于使用错误的下标，导致数组访问越界 b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符 c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读&#x2F;写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。 多线程程序使用了线程不安全的函数。应该使用下面这些可重入的函数，尤其注意红色标示出来的函数，它们很容易被用错：asctime_r(3c) gethostbyname_r(3n) getservbyname_r(3n) ctermid_r(3s) gethostent_r(3n) getservbyport_r(3n) ctime_r(3c) getlogin_r(3c) getservent_r(3n) fgetgrent_r(3c) getnetbyaddr_r(3n) getspent_r(3c) fgetpwent_r(3c) getnetbyname_r(3n) getspnam_r(3c) fgetspent_r(3c) getnetent_r(3n) gmtime_r(3c) gamma_r(3m) getnetgrent_r(3n) lgamma_r(3m) getauclassent_r(3) getprotobyname_r(3n) localtime_r(3c) getauclassnam_r(3) etprotobynumber_r(3n) nis_sperror_r(3n) getauevent_r(3) getprotoent_r(3n) rand_r(3c) getauevnam_r(3) getpwent_r(3c) readdir_r(3c) getauevnum_r(3) getpwnam_r(3c) strtok_r(3c) getgrent_r(3c) getpwuid_r(3c) tmpnam_r(3s) getgrgid_r(3c) getrpcbyname_r(3n) ttyname_r(3c) getgrnam_r(3c) getrpcbynumber_r(3n) gethostbyaddr_r(3n) getrpcent_r(3n). 多线程读写的数据未加锁保护。对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump 非法指针 a) 使用空指针 b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型 的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它 时就很容易因为bus error而core dump. 堆栈溢出不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。 ##coredump文件的生成方法以及使用方法：（假设在x86上交叉编译，而在arm上运行异常的现象）1． 在arm内核里加入coredump的支持（一般内核都支持coredump,不用重编）2． 运行命令，此时允许coredump文件产生：(在arm上) 1ulimit –cunlimited 3． 执行程序：（在arm上）.&#x2F;test在异常退出时，会显示如下信息，注意括号里的内容Segmentation fault (core dumped)程序执行目录下将产生coredump文件4. 用gdb分析：（在x86上）gdb 的选择依赖于目标平台，qnx 提供了以下四种：ARMv7:ntoarmv7-gdbARMv8：ntoaarch64-gdbx86:ntox86-gdbx86 64-bit:ntox86_64-gdb在交叉编译环境下找到可以在x86运行的用于调试target环境的gdb程序。一般位于host&#x2F;linux&#x2F;x86_64&#x2F;usr&#x2F;bin目录下，armv8下程序为ntoaarch64-gdb。运行: 1ntoaarch64-gdb ./test test.coredump 输入run开始调试，再用gdb的bt或where看就可以调试信息了 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Debug","slug":"技术分享/Debug","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Debug/"}],"tags":[{"name":"Debug","slug":"Debug","permalink":"https://dllmayday.github.io/tags/Debug/"}]},{"title":"Hisi3569交叉编译","slug":"hisi3569","date":"2024-02-21T07:14:50.000Z","updated":"2025-08-18T09:22:36.260Z","comments":true,"path":"2024/02/21/hisi3569/","permalink":"https://dllmayday.github.io/2024/02/21/hisi3569/","excerpt":"Hisi3569交叉编译","text":"Hisi3569交叉编译 #1. 系统 ubuntu18.04 64位 由于提供交叉编译程序为32位。需要在64上安装支持32位程序运行库,命令如下 12dpkg --print-architecture #确认64为架构的内核 dpkg --print-foreign-architectures #确认打开了多架构支持功能 输出i386为已打开 ，如果没有需要手动打开 12sudo dpkg --add-architecture i386sudo apt-get update 再执行 123sudo apt-get dist-upgrade ( #这一步是更新所有的软件，如果你对新版本软件的需求不是那么迫切，可以不执行)``` 安装32位支持库 sudo apt install libc6:i386 sudo apt install libstdc++6:i386 12345#2. 下载生成交叉编译环境 aarch64-himix200-linux.tgz。 执行 source ./aarch64-himix200-linux.install [dirname] 生成交叉编译环境到dirname#3. 配置交叉编译环境脚本 ## 编写配置脚本configure-environment.sh,内容如下: #!&#x2F;bin&#x2F;sh SDK_PATH&#x3D;”&#x2F;home&#x2F;username&#x2F;aarch64-himix200-linux&#x2F;“export TOOLCHAIN_SYS&#x3D;aarch64-himix200-linuxexport TOOLCHAIN_PREFIX&#x3D;$TOOLCHAIN_SYS-export SDK_PATH_NATIVE&#x3D;$SDK_PATH&#x2F;export SDK_PATH_TARGET&#x3D;$SDK_PATH&#x2F;targetexport PATH&#x3D;$SDK_PATH_NATIVE&#x2F;bin&#x2F;aarch64-himix200-linux:$PATHexport CPATH&#x3D;$SDK_PATH_TARGET&#x2F;usr&#x2F;include:$CPATHexport PKG_CONFIG_SYSROOT_DIR&#x3D;$SDK_PATH_TARGETexport PKG_CONFIG_PATH&#x3D;$SDK_PATH_TARGET&#x2F;usr&#x2F;lib&#x2F;pkgconfigexport PKG_CONFIG_ALLOW_SYSTEM_LIBS&#x3D;1#export CONFIG_SITE&#x3D;$SDK_PATH&#x2F;site-config-$REAL_MULTIMACH_TARGET_SYSexport CC&#x3D;”${SDK_PATH}&#x2F;bin&#x2F;${TOOLCHAIN_PREFIX}gcc”#–sysroot&#x3D;$SDK_PATH_TARGETexport CXX&#x3D;”${SDK_PATH}&#x2F;bin&#x2F;${TOOLCHAIN_PREFIX}g++” –sysroot&#x3D;$SDK_PATH_TARGETexport GDB&#x3D;${TOOLCHAIN_PREFIX}gdbexport CPP&#x3D;”${TOOLCHAIN_PREFIX}gcc -E –sysroot&#x3D;$SDK_PATH_TARGET”export LD&#x3D;”${TOOLCHAIN_PREFIX}ld –sysroot&#x3D;$SDK_PATH_TARGET”export NM&#x3D;${TOOLCHAIN_PREFIX}nmexport AS&#x3D;${TOOLCHAIN_PREFIX}asexport AR&#x3D;${TOOLCHAIN_PREFIX}arexport RANLIB&#x3D;${TOOLCHAIN_PREFIX}ranlibexport OBJCOPY&#x3D;${TOOLCHAIN_PREFIX}objcopyexport OBJDUMP&#x3D;${TOOLCHAIN_PREFIX}objdumpexport STRIP&#x3D;${TOOLCHAIN_PREFIX}stripexport CONFIGURE_FLAGS&#x3D;”–target&#x3D;aarch64-linux –host&#x3D;aarch64-linux –build&#x3D;x86_64-linux –with-libtool-sysroot&#x3D;$SDK_PATH_TARGET”export CPPFLAGS&#x3D;” –sysroot&#x3D;$SDK_PATH_TARGET”export CFLAGS&#x3D;”$CPPFLAGS”export CXXFLAGS&#x3D;”$CPPFLAGS”export LDFLAGS&#x3D;” –sysroot&#x3D;$SDK_PATH_TARGET”export OECORE_NATIVE_SYSROOT&#x3D;$SDK_PATH_NATIVEexport OECORE_TARGET_SYSROOT&#x3D;$SDK_PATH_TARGETexport OECORE_ACLOCAL_OPTS&#x3D;”-I $SDK_PATH_NATIVE&#x2F;usr&#x2F;share&#x2F;aclocal”export OECORE_DISTRO_VERSION&#x3D;”2020.05”export OECORE_SDK_VERSION&#x3D;”2020.05” Append environment subscriptsif [ -d “$OECORE_TARGET_SYSROOT&#x2F;environment-setup.d” ]; then for envfile in $OECORE_TARGET_SYSROOT&#x2F;environment-setup.d&#x2F;.sh; do . $envfile donefiif [ -d “$OECORE_NATIVE_SYSROOT&#x2F;environment-setup.d” ]; then for envfile in $OECORE_NATIVE_SYSROOT&#x2F;environment-setup.d&#x2F;.sh; do . $envfile donefi 123##cmake 编译工程（1）编写build_hisi.sh,内容如下: #!&#x2F;bin&#x2F;bashsource &#x2F;home&#x2F;username&#x2F;Hisi&#x2F;configure-environment.shcd .&#x2F;build#cmake -DCMAKE_SYSTEM_VERSION&#x3D;”3569” -DCMAKE_SYSTEM_PROCESSOR&#x3D;”aarch64” -DCMAKE_TOOLCHAIN_FILE&#x3D;.&#x2F;toolchain_hisi.cmake -G”Unix Makefiles” ..cmake ..make -j8 4. demo编译 下载解压freetype-2.10.2 修改configure-environment.sh 下SDK_PATH 为自己的路径 build_hisi.sh下修改configure-environment.sh为自己的路径 build_his.sh文件拷贝到freetype-2.10.2解压后CMakeList同级路径。 执行命令: mkdir build ./build_his.sh &lt;hr /&gt; 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"交叉编译","slug":"技术分享/交叉编译","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"交叉编译","slug":"交叉编译","permalink":"https://dllmayday.github.io/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"}]},{"title":"Cmake基本语法","slug":"cmake/Cmake","date":"2024-02-21T07:14:50.000Z","updated":"2025-08-18T09:22:36.252Z","comments":true,"path":"2024/02/21/cmake/Cmake/","permalink":"https://dllmayday.github.io/2024/02/21/cmake/Cmake/","excerpt":"子目录添加12345cmake_minimum_required(VERSION 3.0)project(&lt;工程名&gt;)#将子目录添加到生成中add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL] [SYSTEM])","text":"子目录添加12345cmake_minimum_required(VERSION 3.0)project(&lt;工程名&gt;)#将子目录添加到生成中add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL] [SYSTEM]) 工程构建12345678910111213141516171819202122232425262728293031323334353637383940414243cmake_minimum_required(VERSION 3.0)project(&lt;工程名&gt;)#终端输出当前工程目录message(&quot;Project PATH: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)#设置编译目标输出路径SET(EXECUTABLE_OUTPUT_PATH &lt;输出路径&gt;)#设置编译参数set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -O3 -std=c++14 -fPIC -Wall&quot;)set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -O3 -std=c++14 -fPIC -Wall&quot;)add_compile_options(-std=c++14 -Wno-write-strings -Wno-unused-result -O3)add_definitions(-DFOO -DBAR ...)#库查找find_package(&lt;package&gt; [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [[COMPONENTS] [components...]] [OPTIONAL_COMPONENTS components...] [NO_POLICY_SCOPE])#引入头文件include_directories(&lt;头文件路径&gt;)target_include_directories(target &lt;头文件路径&gt;)#指定链接库路径link_directories(&lt;链接库路径&gt;）#查找在某个路径下的所有源文件,并将输出结果列表储存在指定的变量中aux_source_directory(&lt;路径名&gt; &lt;变量名&gt;)#增加变量set(&lt;变量名&gt; &lt;值&gt;)#指定编译输出add_library(&lt;目标输出名&gt; SHARED &lt;所有源文件列表&gt;)add_library(&lt;目标输出名&gt; STATIC &lt;所有源文件列表&gt;)add_executable(&lt;目标输出名&gt; &lt;所有源文件列表&gt;)#单个目标输出指定链接库target_link_libraries(&lt;工程名&gt; &lt;所有链接的库列表&gt;)#当前cmake下所有目标输出指定链接库link_libraries(&lt;所有链接的库列表&gt;) 查找所有源文件123456#递归获取source/路径下所有的*.cpp和*.c文件列表file(GLOB_RECURSE &lt;变量名&gt; CONFIGURE_DEPENDS &quot;source/*.cpp&quot; &quot;source/*.c&quot;) #查找在某个路径下的所有源文件,并将输出结果列表储存在指定的变量中file(GLOB &lt;变量名&gt;CONFIGURE_DEPENDS &quot;source/*.cpp&quot; &quot;source/*.c&quot;)#查找在某个路径下的所有源文件,并将输出结果列表储存在指定的变量中aux_source_directory(&lt;路径名&gt; &lt;变量名&gt;) 定义函数，把文件夹下所有子文件夹保存在变量中123456789101112131415161718192021macro(list_sub_dir RESULT CUR_DIR FILTER_LIST) file(GLOB_RECURSE CHILDREN LIST_DIRECTORIES true $&#123;CUR_DIR&#125;/*) set(DIR_LIST $&#123;CUR_DIR&#125;) foreach(CHILD $&#123;CHILDREN&#125;) if(IS_DIRECTORY $&#123;CHILD&#125;) set(ADD_FLAG ON) foreach(FILTER $&#123;FILTER_LIST&#125;) string(FIND &quot;$&#123;FILTER&#125;&quot; &quot;$&#123;CHILD&#125;&quot; RET) if($&#123;RET&#125; EQUAL -1) set(ADD_FLAG OFF) endif() endforeach() if($&#123;ADD_FLAG&#125;) list(APPEND DIR_LIST $&#123;CHILD&#125;) endif() unset(ADD_FLAG) endif() endforeach() set($&#123;RESULT&#125; $&#123;DIR_LIST&#125;)endmacro() 自动添加子目录下的CMakeLists1234567file(GLOB SUB_DIRS RELATIVE $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*)foreach(DIR $&#123;SUB_DIRS&#125;) if(EXISTS $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/$&#123;DIR&#125;/CMakeLists.txt) add_subdirectory($&#123;DIR&#125;) endif()endforeach() 获取文件夹名称12get_filename_component(module_name $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; NAME) 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Cmake","slug":"技术分享/Cmake","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Cmake/"}],"tags":[{"name":"Cmake","slug":"Cmake","permalink":"https://dllmayday.github.io/tags/Cmake/"}]},{"title":"欧拉角","slug":"eulor","date":"2024-02-21T03:18:18.000Z","updated":"2025-08-18T09:22:36.255Z","comments":true,"path":"2024/02/21/eulor/","permalink":"https://dllmayday.github.io/2024/02/21/eulor/","excerpt":"欧拉角欧拉角是一种基于三种较简单旋转运动（称为俯仰、滚动和偏航）创建一般旋转的机制。如下图，一架沿x轴方向飞行的飞机可以通过转向左或转向右（偏航），朝上飞或朝下飞（俯仰），或简单绕x轴旋转（滚动）来改变飞行方向。","text":"欧拉角欧拉角是一种基于三种较简单旋转运动（称为俯仰、滚动和偏航）创建一般旋转的机制。如下图，一架沿x轴方向飞行的飞机可以通过转向左或转向右（偏航），朝上飞或朝下飞（俯仰），或简单绕x轴旋转（滚动）来改变飞行方向。 可以看出俯仰、偏航、滚动分别就是绕z轴、y轴、x轴旋转，上面已经给出了这三种特殊旋转的旋转矩阵。这三个矩阵的乘积就可以用来表示一般旋转，图形学中最常使用的定义顺序是将欧拉角表示为(φ, θ, ψ)（说明：φ：滚动角，θ：偏航角，ψ：俯仰角），那么3D空间一般旋转矩阵M就可以表示为三个旋转矩阵的积： M &#x3D; Ryz(ψ)Rzx(θ)Rxy(φ) 代入前面三个旋转矩阵表示如下，我们无需计算具体的结果，就表示为乘积的形式即可，在实际使用中乘积是通过计算机来完成的。这三种旋转是相互独立的，使用这个一般矩阵可以表示3D空间中的任意旋转。 原文地址 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"实用技巧","slug":"技术分享/实用技巧","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"欧拉角","slug":"欧拉角","permalink":"https://dllmayday.github.io/tags/%E6%AC%A7%E6%8B%89%E8%A7%92/"}]},{"title":"GLM矩阵变换","slug":"glmtransform","date":"2024-02-21T03:18:18.000Z","updated":"2025-08-18T09:22:36.257Z","comments":true,"path":"2024/02/21/glmtransform/","permalink":"https://dllmayday.github.io/2024/02/21/glmtransform/","excerpt":"变换方式包括旋转、平移、缩放。 当多种变化叠加影响时按照从后到前的方式进行运算 矩阵运算不满足交换律","text":"变换方式包括旋转、平移、缩放。 当多种变化叠加影响时按照从后到前的方式进行运算 矩阵运算不满足交换律 例如:先平移，再绕z轴逆时针旋转一个角度，最后将其缩放0.5倍 12345glm::mat4 trans(1.0f);trans= glm::translate(trans,glm::vec3(0.5,0.5,0.5));trans= glm::rotate(trans,M_PI/2,glm::vec3(0.0,0.0,1.0));trans = glm::scale(trans, glm::vec3(0.5,0.5,0.5)); 在GLM中，矩阵相乘的顺序是从右到左的，这意味着右边的矩阵先应用，然后左边的矩阵应用。这是因为GLM遵循了OpenGL的标准，而OpenGL中矩阵乘法也是以列主序（Column-Major Order）进行的。直接矩阵相乘写作如下方式 12345glm::mat4 identity(1.0f);glm::mat4 translatemat= glm::translate(identity,glm::vec3(0.5,0.5,0.5));glm::mat4 rotatemat= glm::rotate(identity,M_PI/2,glm::vec3(0.0,0.0,1.0));glm::mat4 scalemat= glm::scale(identity, glm::vec3(0.5,0.5,0.5));trans =scalemat * rotatemat * translatemat; 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"数学","slug":"技术分享/数学","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"GLM","slug":"GLM","permalink":"https://dllmayday.github.io/tags/GLM/"}]},{"title":"Linux中修改环境变量及生效方法","slug":"linuxenv","date":"2024-02-21T02:47:55.000Z","updated":"2025-08-18T09:22:36.261Z","comments":true,"path":"2024/02/21/linuxenv/","permalink":"https://dllmayday.github.io/2024/02/21/linuxenv/","excerpt":"Linux中修改环境变量及生效方法如下： 方法一： &#x2F;etc&#x2F;profile所有用户永久生效在&#x2F;etc&#x2F;profile文件中添加变量,此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行;并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置用vim在文件&#x2F;etc&#x2F;profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。","text":"Linux中修改环境变量及生效方法如下： 方法一： &#x2F;etc&#x2F;profile所有用户永久生效在&#x2F;etc&#x2F;profile文件中添加变量,此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行;并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置用vim在文件&#x2F;etc&#x2F;profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。 例如:编辑&#x2F;etc&#x2F;profile文件，添加CLASSPATH变量添加一行: 1export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib 要让刚才的修改马上生效，需要执行以下代码 1source /etc/profile 方法二：&#x2F;etc&#x2F;bashrc所有用户永久生效为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。 编辑方法如上，不再赘述 方法三 ~&#x2F;.bash_profile仅对当前用户永久有效：在~&#x2F;.bash_profile文件中增加变量【对单一用户生效（永久的）】, 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。用vim在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。修改后需要执行重新登录才能生效，也可以执行命令source &#x2F;etc&#x2F;profile立即生效 1source .bash_profile 方法四 ~&#x2F;.bashrc仅会对当前用户有效：在~&#x2F;.bashrc文件中增加专用于当前用户的bashshell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。编辑方法如上，不再赘述另外，.bashrc等中设定的变量(局部)只能继承&#x2F;etc&#x2F;profile中的变量,他们是”父子”关系 方法四：直接运行export命令定义变量【只对当前shell（BASH）有效（临时的）】在shell的命令行下直接使用[export 变量名&#x3D;变量值]定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。 例如： 1export PATH=/usr/local/webserver/php/bin:$PATH 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Linux","slug":"技术分享/Linux","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Linux/"}],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"https://dllmayday.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"}]},{"title":"C++代码内部执行命令方法","slug":"cppruncmd","date":"2024-02-21T02:10:17.000Z","updated":"2025-08-18T09:22:36.253Z","comments":true,"path":"2024/02/21/cppruncmd/","permalink":"https://dllmayday.github.io/2024/02/21/cppruncmd/","excerpt":"在C++代码中执行命令有几种方法，每种方法都有其自身的优缺点。以下是一些常见的方法：","text":"在C++代码中执行命令有几种方法，每种方法都有其自身的优缺点。以下是一些常见的方法： std::system函数：123456#include &lt;cstdlib&gt;int main() &#123; std::system(&quot;command_to_execute&quot;); return 0;&#125; 优点：简单易用，适用于执行简单的命令。缺点：不够灵活，不能捕获命令执行的输出，容易受到系统命令注入等安全问题。 std::popen函数：123456789101112#include &lt;cstdio&gt;int main() &#123; FILE* pipe = std::popen(&quot;command_to_execute&quot;, &quot;r&quot;); if (!pipe) return 1; char buffer[128]; while (fgets(buffer, sizeof(buffer), pipe) != nullptr) &#123; // 处理命令输出 &#125; std::pclose(pipe); return 0;&#125; 优点：能够捕获命令执行的输出。缺点：依然不够灵活，无法实时捕获命令输出。使用操作系统特定的API： 每个操作系统都提供了执行外部命令的API，比如Windows下的CreateProcess&#x2F;WinExec&#x2F;ShellExecute或调用vbs脚本，Linux&#x2F;Unix下的fork和exec等。这种方法更灵活，但是需要了解操作系统特定的API，代码可移植性差。 第三方库：有一些第三方库，比如Boost.Process，可以在C++中执行外部命令，并提供了更高级的功能，比如异步执行、捕获输出等。C++17中的std::filesystem::path::lexically_normal: 使用C++17中的 std::filesystem::path::lexically_normal 和 std::filesystem::directory_iterator 可以遍历目录和文件。 12345678910#include &lt;filesystem&gt;namespace fs = std::filesystem;#include &lt;iostream&gt;int main() &#123; for (const auto&amp; entry : fs::directory_iterator(&quot;/path/to/directory&quot;)) &#123; std::cout &lt;&lt; entry.path().lexically_normal() &lt;&lt; std::endl; &#125; return 0;&#125; 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"实用技巧","slug":"技术分享/实用技巧","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"https://dllmayday.github.io/tags/cmd/"}]},{"title":"windows下查找程序运行所需要的依赖库","slug":"winfindlib","date":"2024-02-20T10:30:38.000Z","updated":"2025-08-18T09:22:36.265Z","comments":true,"path":"2024/02/20/winfindlib/","permalink":"https://dllmayday.github.io/2024/02/20/winfindlib/","excerpt":"如果安装了VS，可以用VS下自带的一个命令行工具：dumpbin.exe 我的路径为：C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\bin打开cmd.exe，cd到该路径后，输入： .\\dumpbin -dependents xx.dll （全路径）或.\\dumpbin \\dependents xx.exe （全路径）","text":"如果安装了VS，可以用VS下自带的一个命令行工具：dumpbin.exe 我的路径为：C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\bin打开cmd.exe，cd到该路径后，输入： .\\dumpbin -dependents xx.dll （全路径）或.\\dumpbin \\dependents xx.exe （全路径） 我的程序是Qt程序,Qt环境自带查找依赖工具定位到Qt环境D:\\Qt\\Qt5.5.0\\5.5\\msvc2013\\bin(看自己的安装路径)下找到windeployqt.exe 命令行执行：.\\windeployqt.exe xx.exe （全路径）此时会自动将所需的类库、文件等拷贝到程序或库所在路径下 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"实用技巧","slug":"技术分享/实用技巧","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"dependents","slug":"dependents","permalink":"https://dllmayday.github.io/tags/dependents/"}]},{"title":"VisualStudio Release模型下调试设置","slug":"vsreleasemodedebug","date":"2024-02-20T10:20:50.000Z","updated":"2025-08-18T09:22:36.265Z","comments":true,"path":"2024/02/20/vsreleasemodedebug/","permalink":"https://dllmayday.github.io/2024/02/20/vsreleasemodedebug/","excerpt":"在有的情况下，我们可能不能直接利用Debug模式进行程序调试，那么如何在Release模式下进行程序调试呢？","text":"在有的情况下，我们可能不能直接利用Debug模式进行程序调试，那么如何在Release模式下进行程序调试呢？ 一、将项目属性设置为Release，生成—&gt;配置管理器： 二、按Alt+F7，弹出属性页进行设置： 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Visual Studio","slug":"技术分享/Visual-Studio","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Visual-Studio/"}],"tags":[{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://dllmayday.github.io/tags/VisualStudio/"}]},{"title":"判断字符串编码方式","slug":"strencode","date":"2024-02-20T10:16:10.000Z","updated":"2025-08-18T09:22:36.262Z","comments":true,"path":"2024/02/20/strencode/","permalink":"https://dllmayday.github.io/2024/02/20/strencode/","excerpt":"判断字符串编码为UTF-8还是GBK","text":"判断字符串编码为UTF-8还是GBK UTF8123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354bool is_str_utf8(const char* str)&#123; unsigned int nBytes = 0;//UFT8可用1-6个字节编码,ASCII用一个字节 unsigned char chr = *str; bool bAllAscii = true; for (unsigned int i = 0; str[i] != &#x27;\\0&#x27;; ++i)&#123; chr = *(str + i); //判断是否ASCII编码,如果不是,说明有可能是UTF8,ASCII用7位编码,最高位标记为0,0xxxxxxx if (nBytes == 0 &amp;&amp; (chr &amp; 0x80) != 0)&#123; bAllAscii = false; &#125; if (nBytes == 0) &#123; //如果不是ASCII码,应该是多字节符,计算字节数 if (chr &gt;= 0x80) &#123; if (chr &gt;= 0xFC &amp;&amp; chr &lt;= 0xFD)&#123; nBytes = 6; &#125; else if (chr &gt;= 0xF8)&#123; nBytes = 5; &#125; else if (chr &gt;= 0xF0)&#123; nBytes = 4; &#125; else if (chr &gt;= 0xE0)&#123; nBytes = 3; &#125; else if (chr &gt;= 0xC0)&#123; nBytes = 2; &#125; else&#123; return false; &#125; nBytes--; &#125; &#125; else&#123; //多字节符的非首字节,应为 10xxxxxx if ((chr &amp; 0xC0) != 0x80)&#123; return false; &#125; //减到为零为止 nBytes--; &#125; &#125; //违返UTF8编码规则 if (nBytes != 0) &#123; return false; &#125; if (bAllAscii)&#123; //如果全部都是ASCII, 也是UTF8 return true; &#125; return true;&#125; GBK123456789101112131415161718192021222324252627282930313233343536bool is_str_gbk(const char* str)&#123; unsigned int nBytes = 0;//GBK可用1-2个字节编码,中文两个 ,英文一个 unsigned char chr = *str; bool bAllAscii = true; //如果全部都是ASCII, for (unsigned int i = 0; str[i] != &#x27;\\0&#x27;; ++i)&#123; chr = *(str + i); if ((chr &amp; 0x80) != 0 &amp;&amp; nBytes == 0)&#123;// 判断是否ASCII编码,如果不是,说明有可能是GBK bAllAscii = false; &#125; if (nBytes == 0) &#123; if (chr &gt;= 0x80) &#123; if (chr &gt;= 0x81 &amp;&amp; chr &lt;= 0xFE)&#123; nBytes = +2; &#125; else&#123; return false; &#125; nBytes--; &#125; &#125; else&#123; if (chr &lt; 0x40 || chr&gt;0xFE)&#123; return false; &#125; nBytes--; &#125;//else end &#125; if (nBytes != 0) &#123; //违返规则 return false; &#125; if (bAllAscii)&#123; //如果全部都是ASCII, 也是GBK return true; &#125; return true;&#125; 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"实用技巧","slug":"技术分享/实用技巧","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"encoding","slug":"encoding","permalink":"https://dllmayday.github.io/tags/encoding/"}]},{"title":"WSL图像界面安装","slug":"wsl","date":"2024-02-20T10:12:32.000Z","updated":"2025-08-18T09:22:36.265Z","comments":true,"path":"2024/02/20/wsl/","permalink":"https://dllmayday.github.io/2024/02/20/wsl/","excerpt":"WSL图像界面安装教程","text":"WSL图像界面安装教程 安装WSL 换源参考另一篇文章https://www.cnblogs.com/bosslv/p/11006680.html 修改$PATH，默认会把windows的PATH也加入WSL中，不需要的话可以删除 1sudo vim ~/.bashrc 末尾加入如下代码PATH=$(/usr/bin/printenv PATH | /usr/bin/perl -ne &#39;print join(&quot;:&quot;, grep &#123; !/\\/mnt\\/[a-z]/ &#125; split(/:/));&#39;) 设置中文环境 下载中文语言包 1sudo apt-get install language-pack-zh-han* 编辑配置文件 1sudo vim /etc/profile 末尾加入 12export LANG=zh_CN.utf8export LC_ALL=zh_CN.utf8 添加中文字体sudo apt-get install fonts-noto-cjk 重启 安装图形界面 windows下载安装VcXsrv，地址https://sourceforge.net/projects/vcxsrv/ WSL安装xfce4 1sudo apt-get install --assume-yes xfce4 xorg-dev libopencc2 libopencc2-data libqt4-opengl libqtwebkit4 unzip zip 设置配置文件~/.bashrc 1echo &quot;export DISPLAY=:0.0&quot; &gt;&gt; ~/.bashrc 重启WSL Windows上打开XLaunch WSL输入$ startxfce4 如果桌面显示出现问题，在WSL中执行 12rm -rf ~/.config/xfce4rm -rf ~/.cache/sessions 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"实用技巧","slug":"技术分享/实用技巧","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"WSL","slug":"WSL","permalink":"https://dllmayday.github.io/tags/WSL/"}]},{"title":"GLOG参数说明","slug":"glogparams","date":"2024-02-20T09:10:43.000Z","updated":"2025-08-18T09:22:36.257Z","comments":true,"path":"2024/02/20/glogparams/","permalink":"https://dllmayday.github.io/2024/02/20/glogparams/","excerpt":"GLOG参数设置： –logtostderr：将日志输出到标准错误流而不是日志文件。–stderrthreshold&#x3D;：设置将输出到标准错误流的日志消息的最低严重程度。–log_dir&#x3D;：设置日志文件输出目录。–minloglevel&#x3D;：设置记录到日志文件的最低严重程度。–v&#x3D;：设置日志的详细级别。可以是一个整数，控制日志的详细程度，较高的值会产生更多的详细信息。–vmodule&#x3D;：设置特定模块的详细级别。可以指定模块名称和详细级别，以逗号分隔。–alsologtostderr：将日志同时输出到日志文件和标准错误流。–colorlogtostderr：在终端输出彩色日志。","text":"GLOG参数设置： –logtostderr：将日志输出到标准错误流而不是日志文件。–stderrthreshold&#x3D;：设置将输出到标准错误流的日志消息的最低严重程度。–log_dir&#x3D;：设置日志文件输出目录。–minloglevel&#x3D;：设置记录到日志文件的最低严重程度。–v&#x3D;：设置日志的详细级别。可以是一个整数，控制日志的详细程度，较高的值会产生更多的详细信息。–vmodule&#x3D;：设置特定模块的详细级别。可以指定模块名称和详细级别，以逗号分隔。–alsologtostderr：将日志同时输出到日志文件和标准错误流。–colorlogtostderr：在终端输出彩色日志。 1234567891011121314151617181920212223242526#include &lt;glog/logging.h&gt;int main(int argc, char* argv[]) &#123; // 初始化 Google 日志库 google::InitGoogleLogging(argv[0]); // 设置日志输出目录 FLAGS_log_dir = &quot;/path/to/log/directory&quot;; // 设置日志的最低记录级别 FLAGS_minloglevel = google::INFO; // 可以设置为 google::INFO、google::WARNING、google::ERROR 等级别 // 设置日志详细级别 FLAGS_v = 2; // 设置为2，表示输出详细级别为2的日志信息 // 执行你的程序逻辑 LOG(INFO) &lt;&lt; &quot;这是一个信息级别的日志消息&quot;; LOG(WARNING) &lt;&lt; &quot;这是一个警告级别的日志消息&quot;; LOG(ERROR) &lt;&lt; &quot;这是一个错误级别的日志消息&quot;; // 关闭 Google 日志库 google::ShutdownGoogleLogging(); return 0;&#125; 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"GLOG","slug":"技术分享/GLOG","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/GLOG/"}],"tags":[{"name":"glog","slug":"glog","permalink":"https://dllmayday.github.io/tags/glog/"}]},{"title":"linuxcommond","slug":"linuxcommond","date":"2024-02-20T09:05:53.000Z","updated":"2025-08-18T09:22:36.261Z","comments":true,"path":"2024/02/20/linuxcommond/","permalink":"https://dllmayday.github.io/2024/02/20/linuxcommond/","excerpt":"Linux 命令行使用","text":"Linux 命令行使用 磁盘占用12345678//默认显示系统所有的磁盘情况//(-h 参数同样是为了提高可读性，-s 代表summary，只显示总大小)df -h//(-h 参数同样是为了提高可读性，-s 代表summary，只显示总大小)//默认显示当前目录下所有文件和文件夹的总大小。du -sh 依赖 查看依赖的库： 1objdump -x xxx.so | grep NEEDED 查看可执行程序依赖的库： 1objdump -x 可执行程序名 | grep NEEDED 查看库导出函数 12objdump -tT xxx.sonm -D xxx.so 查看符号表 地址： 12objdump -tT libName.so | grep symbel symbolNamenm -D libName.so | grep symbel symbolName 查看缺少的库： 1ldd xxx.so 查看库版本编译等信息：strings xxx.so 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Linux","slug":"技术分享/Linux","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://dllmayday.github.io/tags/Linux/"}]},{"title":"Beyond Compare密钥失效解决","slug":"beyondcompare","date":"2024-02-20T09:02:40.000Z","updated":"2025-08-18T09:22:36.251Z","comments":true,"path":"2024/02/20/beyondcompare/","permalink":"https://dllmayday.github.io/2024/02/20/beyondcompare/","excerpt":"","text":"查找路径C:\\Users&lt;用户名&gt;\\AppData\\Roaming\\Scooter Software\\Beyond Compare 4删除除BC4Key.txt外所有文件 第二种办法 删除C:\\Program Files\\Beyond Compare 4\\BCUnrar.dll（安装目录下的BCUnrar.dll文件]），这个文件重命名或者直接删除。 第三种办法修改注册表1、在搜索栏中输入 regedit ，打开注册表2、删除项目CacheId ：HKEY_CURRENT_USER\\Software\\Scooter Software\\Beyond Compare 4\\CacheId 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"实用技巧","slug":"技术分享/实用技巧","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Beyond Compare","slug":"Beyond-Compare","permalink":"https://dllmayday.github.io/tags/Beyond-Compare/"}]},{"title":"vmware-ubuntu使用问题解决","slug":"vmwareubuntu","date":"2024-02-20T09:00:32.000Z","updated":"2025-08-18T09:22:36.264Z","comments":true,"path":"2024/02/20/vmwareubuntu/","permalink":"https://dllmayday.github.io/2024/02/20/vmwareubuntu/","excerpt":"","text":"无法联网sudo service network-manager stopsudo rm &#x2F;var&#x2F;lib&#x2F;NetworkManager&#x2F;NetworkManager.statesudo service network-manager start sudo gedit &#x2F;etc&#x2F;NetworkManager&#x2F;NetworkManager.conf把 managed &#x3D;false改成true 磁盘空间压缩sudo &#x2F;usr&#x2F;bin&#x2F;vmware-toolbox-cmd disk listsudo &#x2F;usr&#x2F;bin&#x2F;vmware-toolbox-cmd disk shrink &#x2F; ubuntu系统安装中文输入法一. 安装输入法下面任选一种即可： IBus拼音：sudo apt-get install ibus-pinyin （命令解释：sudo 以超级权限去执行，apt-get install 安装一个新软件包 ibus-pinyin软件包名称）谷歌拼音输入法：sudo apt-get install ibus-googlepinyinSun拼音输入法：sudo apt-get install ibus-sunpinyin二.配置输入法：终端里面输入ibus-setup，输入法的配置界面就会弹出，IBus Preference设置被打开。我们在Input Method选项卡中，选择自己喜欢的输入方式，并配置自己喜欢的快捷键即可。注意：如果发现切换中英文的小图标在左上角没有出现，可以打开系统设置在地区和语言中添加Chinese（pinyin）就会显示 若以上步骤无效时，参考一下步骤：打开命令行依次输入： sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4启动：im-config -s -ibus安装pinyin引擎：sudo apt-get install ibus-pinyin打开设置：ibus-setup，添加pinyin VMware 上使用 Ubuntu 20 虚拟机时无法显示共享磁盘的问题解决VMware Tools 安装： 确保您已经在 Ubuntu 20 虚拟机中安装了 VMware Tools。VMware Tools 提供了一些增强功能，包括共享文件夹的支持。您可以在 VMware 虚拟机菜单中找到安装 VMware Tools 的选项。 共享文件夹设置： 在 VMware 虚拟机设置中，确保已正确配置共享文件夹。您可以通过编辑虚拟机设置，然后在 “选项” 标签卡下选择 “共享文件夹” 来配置共享文件夹。 检查权限： 确保您在 Ubuntu 中有足够的权限访问共享文件夹。确保您的用户属于正确的用户组，并且有权限读取和写入共享文件夹。 重新挂载共享文件夹： 在 Ubuntu 中，您可以尝试重新挂载共享文件夹。使用以下命令： sudo vmware-hgfsclientsudo vmhgfs-fuse .host:&#x2F; &#x2F;mnt&#x2F;hgfs&#x2F; -o allow_other12这将共享文件夹挂载到 &#x2F;mnt&#x2F;hgfs&#x2F; 目录中。请确保该目录存在。 查看日志： 检查 VMware Tools 的日志文件，看是否有关于共享文件夹的错误或警告。您可以在 &#x2F;var&#x2F;log&#x2F;vmware-tools 目录中找到这些日志文件。 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"实用技巧","slug":"技术分享/实用技巧","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"vmware","slug":"vmware","permalink":"https://dllmayday.github.io/tags/vmware/"}]},{"title":"颜色转换","slug":"cvtcolor","date":"2024-02-20T08:53:20.000Z","updated":"2025-08-18T09:22:36.254Z","comments":true,"path":"2024/02/20/cvtcolor/","permalink":"https://dllmayday.github.io/2024/02/20/cvtcolor/","excerpt":"misc colorspace conversion functions","text":"misc colorspace conversion functions 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950/***************************************************************************** * colorspace.c: misc colorspace conversion functions ***************************************************************************** * $Id: colorspace.c,v 1.16 2005/08/11 23:25:01 pingus77 Exp $ ***************************************************************************** * Copyright (C) 1998 Gerd Knorr &lt;kraxel@cs.tu-berlin.de&gt; * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111, USA. ***************************************************************************** * * misc colorspace conversion functions * *****************************************************************************/#include &quot;config.h&quot;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &quot;colorspace.h&quot;#include &quot;memcpy.h&quot;#include &quot;strtab.h&quot;extern int debug;struct STRTAB video_fmt_names[] = &#123; &#123;VIDEO_RGB03,&quot;rgb3&quot;&#125;, &#123;VIDEO_RGB04b,&quot;rgb4b&quot;&#125;, &#123;VIDEO_RGB08,&quot;rgb8&quot;&#125;, &#123;VIDEO_RGB08b,&quot;rgb8b&quot;&#125;, &#123;VIDEO_RGB15,&quot;rgb15&quot;&#125;, &#123;VIDEO_RGB16,&quot;rgb16&quot;&#125;, &#123;VIDEO_RGB24,&quot;rgb24&quot;&#125;, &#123;VIDEO_RGB24B,&quot;rgb24b&quot;&#125;, &#123;VIDEO_RGB32,&quot;rgb32&quot;&#125;, &#123;VIDEO_RGB32B,&quot;rgb32b&quot;&#125;, &#123;VIDEO_RGB32P,&quot;rgb32p&quot;&#125;, &#123;VIDEO_RGB15X,&quot;rgb15x&quot;&#125;, &#123;VIDEO_RGB16X,&quot;rgb16x&quot;&#125;, &#123;VIDEO_RGB24X,&quot;rgb24x&quot;&#125;, &#123;VIDEO_RGB32X,&quot;rgb32x&quot;&#125;, &#123;VIDEO_RGB32PX,&quot;rgb32px&quot;&#125;, &#123;VIDEO_HI240,&quot;hi240&quot;&#125;, &#123;VIDEO_GRAY1,&quot;gray1&quot;&#125;, &#123;VIDEO_GRAY1X,&quot;gray1x&quot;&#125;, &#123;VIDEO_GRAY4,&quot;gray4&quot;&#125;, &#123;VIDEO_GRAY8,&quot;gray8&quot;&#125;, &#123;VIDEO_YUYV, &quot;yuyv&quot;&#125;, &#123;VIDEO_UYVY, &quot;uyvy&quot;&#125;, &#123;VIDEO_YUV420,&quot;yuv420&quot;&#125;, &#123;VIDEO_YVU420,&quot;yvu420&quot;&#125;, &#123;VIDEO_Y41P, &quot;y41p&quot;&#125;, &#123;VIDEO_YVU410, &quot;yvu410&quot;&#125;, &#123;VIDEO_YUV410, &quot;yuv410&quot;&#125;, &#123;VIDEO_YUV422P, &quot;yuv422p&quot;&#125;, &#123;VIDEO_YUV411P, &quot;yuv411p&quot;&#125;, &#123;VIDEO_NV12, &quot;nv12&quot;&#125;, &#123;-1, NULL&#125;&#125;;static voidrgb4b_to_rgb32 (unsigned char *dest, unsigned char *s, int w, int h)&#123; int i, *d = (int *)dest; for (i=w*h; i&gt;0; i--, d++, s++) &#123; unsigned int c=*s; *d = ((c &amp; 0x3) &lt;&lt; (16+6)) | (((c &gt;&gt; 2)&amp;0x1) &lt;&lt; (8+7)) | (c&gt;&gt;3&lt;&lt;7); &#125;&#125;static voidrgb32_to_rgb4b (unsigned char *d, unsigned char *src, int w, int h)&#123; int i, *s = (int *)src; for (i=w*h; i&gt;0; i--, d++, s++) &#123; unsigned int c=*s; *d = (c&gt;&gt;(16+6)) | ((c&amp;0xFF00)&gt;&gt;(8+7)&lt;&lt;2) | ((c &amp; 0xFF)&gt;&gt;7&lt;&lt;3); &#125;&#125;static voidrgb8b_to_rgb32 (unsigned char *dest, unsigned char *s, int w, int h)&#123; int i, *d = (int *)dest; for (i=w*h; i&gt;0; i--, d++, s++) &#123; unsigned int c=*s; *d = ((c &amp; 0x7) &lt;&lt; (16+5)) | (((c &gt;&gt; 3)&amp;0x7) &lt;&lt; (8+5)) | (c&gt;&gt;6&lt;&lt;6); &#125;&#125;static voidrgb32_to_rgb8b (unsigned char *d, unsigned char *src, int w, int h)&#123; int i, *s = (int *)src; for (i=w*h; i&gt;0; i--, d++, s++) &#123; unsigned int c=*s; *d = (c&gt;&gt;(16+5)) | ((c&amp;0xFF00)&gt;&gt;(8+5)&lt;&lt;3) | ((c &amp; 0xFF)&gt;&gt;6&lt;&lt;6); &#125;&#125;static voidrgb8_to_rgb32 (unsigned char *dest, unsigned char *s, int w, int h)&#123; int i, *d = (int *)dest; for (i=w*h; i&gt;0; i--, d++, s++) &#123; unsigned int c=*s; *d = ((c &gt;&gt; 6) &lt;&lt; (16+6)) | (((c &gt;&gt; 3)&amp;0x7) &lt;&lt; (8+5)) | ((c &amp; 0x7) &lt;&lt; 5); &#125;&#125;static voidrgb32_to_rgb8 (unsigned char *d, unsigned char *src, int w, int h)&#123; int i, *s = (int *)src; for (i=w*h; i&gt;0; i--, d++, s++) &#123; unsigned int c=*s; *d = ((c&gt;&gt;(16+6))&lt;&lt;6) | ((c&amp;0xFF00)&gt;&gt;(8+5)&lt;&lt;3) | ((c &amp; 0xFF)&gt;&gt;5); &#125;&#125;static voidrgb15_to_rgb32 (unsigned char *dest, unsigned char *src, int w, int h)&#123; int i, *d = (int *)dest; short *s = (short *)src; for (i=w*h; i&gt;0; i--, d++, s++) &#123; unsigned int c=*s; *d = ((c &gt;&gt; 10) &lt;&lt; (16+3)) | (((c &gt;&gt; 5)&amp;0x1F) &lt;&lt; (8+3)) | ((c &amp; 0x1F) &lt;&lt; 3); &#125;&#125;static voidrgb32_to_rgb15 (unsigned char *dest, unsigned char *src, int w, int h)&#123; int i, *s = (int *)src; short *d = (short *)dest; for (i=w*h; i&gt;0; i--, d++, s++) &#123; unsigned int c=*s; *d = ((c&gt;&gt;(16+3))&lt;&lt;10) | ((c&amp;0xFF00)&gt;&gt;(8+3)&lt;&lt;5) | ((c &amp; 0xFF)&gt;&gt;3); &#125;&#125;static voidrgb16_to_rgb32 (unsigned char *dest, unsigned char *src, int w, int h)&#123; int i, *d = (int *)dest; short *s = (short *)src; for (i=w*h; i&gt;0; i--, d++, s++) &#123; unsigned int c=*s; *d = ((c &gt;&gt; 11) &lt;&lt; (16+3)) | (((c &gt;&gt; 5)&amp;0x3F) &lt;&lt; (8+2)) | ((c &amp; 0x1F) &lt;&lt; 3); &#125;&#125;static voidrgb32_to_rgb16 (unsigned char *dest, unsigned char *src, int w, int h)&#123; int i, *s = (int *)src; short *d = (short *)dest; for (i=w*h; i&gt;0; i--, d++, s++) &#123; unsigned int c=*s; *d = ((c&gt;&gt;(16+3))&lt;&lt;11) | ((c&amp;0xFF00)&gt;&gt;(8+2)&lt;&lt;5) | ((c &amp; 0xFF)&gt;&gt;3); &#125;&#125;static voidrgb24_to_rgb32 (unsigned char *dest, unsigned char *src, int w, int h)&#123; int i = w * h; while (i--) &#123;#ifdef WORDS_BIGENDIAN *(dest++) = 0;#endif *(dest++) = *(src++); *(dest++) = *(src++); *(dest++) = *(src++);#ifndef WORDS_BIGENDIAN *(dest++) = 0;#endif &#125;&#125;static voidrgb32_to_rgb24 (unsigned char *dest, unsigned char *src, int w, int h)&#123; int i = w * h; while (i--) &#123;#ifdef WORDS_BIGENDIAN src++;#endif *(dest++) = *(src++); *(dest++) = *(src++); *(dest++) = *(src++);#ifndef WORDS_BIGENDIAN src++;#endif &#125;&#125;static void gray1_to_gray8(unsigned char *d, unsigned char *s, int w, int h) &#123; int x,y,z,dpad=((w+31)/32*4-w/8); /* the width must be multiple of 32, (just assumed to be multiple of 4 in xdtv, see x11.c) */ for(y=h;y&gt;0;y--) &#123; for(x=w;x&gt;7;x-=8,s++,d+=8) for(z=0;z&lt;8;z++)#ifdef WORDS_BIGENDIAN d[z]=(*s&amp;(1&lt;&lt;(8-z)))?255:0;#else d[z]=(*s&amp;(1&lt;&lt;z))?255:0;#endif s+=dpad; &#125;&#125;static void gray8_to_gray1(unsigned char *d, unsigned char *s, int w, int h) &#123; int x,y,dpad=((w+31)/32*4-w/8); /* the width must be multiple of 32, (just assumed to be multiple of 4 in xdtv, see x11.c) */ for(y=h;y&gt;0;y--) &#123; for(x=w;x&gt;7;x-=8,d++,s+=8)#ifdef WORDS_BIGENDIAN *d=(s[7]&gt;&gt;7)|(s[6]&gt;&gt;7&lt;&lt;1)|(s[5]&gt;&gt;7&lt;&lt;2)|(s[4]&gt;&gt;7&lt;&lt;3)|(s[3]&gt;&gt;7&lt;&lt;4)|(s[2]&gt;&gt;7&lt;&lt;5) |(s[1]&gt;&gt;7&lt;&lt;6)|(s[0]&gt;&gt;7&lt;&lt;7);#else *d=(s[0]&gt;&gt;7)|(s[1]&gt;&gt;7&lt;&lt;1)|(s[2]&gt;&gt;7&lt;&lt;2)|(s[3]&gt;&gt;7&lt;&lt;3)|(s[4]&gt;&gt;7&lt;&lt;4)|(s[5]&gt;&gt;7&lt;&lt;5) |(s[6]&gt;&gt;7&lt;&lt;6)|(s[7]&gt;&gt;7&lt;&lt;7);#endif d+=dpad; &#125;&#125;static void gray4_to_gray8(unsigned char *d, unsigned char *s, int w, int h) &#123; int i; for (i=w*h; i&gt;0; i--, d++, s++) *d=*s&lt;&lt;4;&#125;static void gray8_to_gray4(unsigned char *d, unsigned char *s, int w, int h) &#123; int i; for (i=w*h; i&gt;0; i--, d++, s++) *d=*s&gt;&gt;4;&#125;static void yuv420_to_gray8(unsigned char *dest, unsigned char *src, int width, int height) &#123; fast_memcpy(dest, src, width*height);&#125;static void gray8_to_yuv420(unsigned char *dest, unsigned char *src, int width, int height) &#123; int size=width*height; fast_memcpy(dest, src, size); dest+=size; size/=4; memset(dest, 128, size); dest+=size; memset(dest, 128, size);&#125;/* rgb4 is xdtv-specific ! (just for fun :&gt;)*/static void rgb3_to_rgb32(unsigned char *dd, unsigned char *s, int w, int h) &#123; unsigned int *d=(unsigned int *)dd; int i; for (i=w*h; i&gt;0; i--, d++, s++) *d=((*s&amp;1)&lt;&lt;(7-0))|((*s&amp;2)&lt;&lt;(15-1))|((*s&amp;4)&lt;&lt;(23-2));&#125;static void rgb32_to_rgb3(unsigned char *d, unsigned char *ss, int w, int h) &#123; unsigned int *s=(unsigned int *)ss; int i; for (i=w*h; i&gt;0; i--, d++, s++) *d = ((s[0]&gt;&gt;7)&amp;1)|(((s[0]&gt;&gt;15)&amp;1)&lt;&lt;1)|(((s[0]&gt;&gt;23)&amp;1)&lt;&lt;2);&#125; static void hi240_to_rgb32(unsigned char *dest, unsigned char *src, int w, int h) &#123; static int *rgb32_conv=NULL; int i; int *dest2=(int *)dest; if(rgb32_conv==NULL) &#123; rgb32_conv=(int *) malloc(256*sizeof(int)); for(i=0;i&lt;225;i++) &#123; int r=((i/5)%5)*255.0/4+0.5; int g=(i/25)*255.0/8+0.5; int b=(i%5)*255.0/4+0.5; rgb32_conv[16+i]=(b&lt;&lt;0)|(g&lt;&lt;8)|(r&lt;&lt;16); &#125; &#125; for(i=w*h;i&gt;0;i--,dest2++,src++) *dest2=rgb32_conv[*src];&#125;static void rgb32_to_hi240(unsigned char *d, unsigned char *s, int w, int h) &#123; int i; for (i=w*h; i&gt;0; i--, d++, s+=4) &#123;#ifdef WORDS_BIGENDIAN *d = 16 + s[3]/52 + s[1]/52*5 + s[2]/29*25;#else *d = 16 + s[0]/52 + s[2]/52*5 + s[1]/29*25;#endif &#125;&#125;static void yvu420_yuv420(unsigned char *d, unsigned char *s, int w, int h) &#123; unsigned char *as, *bs, *ad, *bd; int t = w*h / 4; as = s + t*4; bs = as+ t; ad = d + t*4; bd = ad+ t; fast_memcpy(d, s, t*4); fast_memcpy(ad, bs, t); fast_memcpy(bd, as, t);&#125;static void rgb32_rgb32b(unsigned char *d, unsigned char *s, int w, int h) &#123; int t = 4*w, y; s += t * (h - 1); for (y = h; y &gt; 0; y--) &#123; fast_memcpy(d, s, t); d += t; s -= t; &#125;&#125;static void rgb24_rgb24b(unsigned char *d, unsigned char *s, int w, int h) &#123; int t = 3*w, y; s += t * (h - 1); for (y = h; y &gt; 0; y--) &#123; fast_memcpy(d, s, t); d += t; s -= t; &#125;&#125;static void swap1bpp32(unsigned char *dest, unsigned char *src, int w, int h) &#123; int *d=(int *)dest,*s=(int *)src,ss,dd,i,j; for(i=w*h/32; i&gt;0; i--,s++,d++) &#123; ss=*s;dd=0; for(j=0;j&lt;32;j++) if(ss&amp;(1&lt;&lt;j)) dd|=(1&lt;&lt;(32-j)); *d=dd; &#125;&#125;static void swap16bpp(unsigned char *d, unsigned char *s, int w, int h) &#123; int i; //swab(d, s, 2*w*h); for(i=w*h; i&gt;0; i--,s+=2,d+=2) &#123; d[0]=s[1]; d[1]=s[0];&#125;&#125;static void swap24bpp(unsigned char *d, unsigned char *s, int w, int h) &#123; int i; for(i=w*h; i&gt;0; i--,s+=3,d+=3) &#123; d[0]=s[2]; d[1]=s[1]; d[2]=s[0];&#125;&#125;static void swap32bpp(unsigned char *d, unsigned char *s, int w, int h) &#123; int i; for(i=w*h; i&gt;0; i--,s+=4,d+=4) &#123; d[0]=s[3]; d[1]=s[2]; d[2]=s[1]; d[3]=s[0];&#125;&#125;void swap24(unsigned char *m, int t) &#123; int i; unsigned char c; for(i=t; i&gt;0; i--, m+=3) &#123; c=m[0]; m[0]=m[2]; m[2]=c; &#125; &#125;static void yuyv_to_yuv420 (unsigned char *d, unsigned char *s, int w, int h)&#123; int a, b; unsigned char *y, *u, *v; y = d; u = y + w * h; v = u + w * h / 4; for (a = h; a &gt; 0; a -= 2) &#123; for (b = w; b &gt; 0; b -= 2) &#123; *(y++) = *(s++); *(u++) = *(s++); *(y++) = *(s++); *(v++) = *(s++); &#125; for (b = w; b &gt; 0; b -= 2) &#123; *(y++) = *(s++); s++; *(y++) = *(s++); s++; &#125; &#125;&#125; vx_imagepatch_addressing_t input_addr; vx_rectangle_t rect; vx_map_id input_id; void *input_ptr; rect.start_x = 0; rect.start_y = 0; rect.end_x = obj-&gt;input_image_width; rect.end_y = obj-&gt;input_image_height; vxMapImagePatch(obj-&gt;input_img[0], &amp;rect, 0, &amp;input_id, &amp;input_addr, &amp;input_ptr, VX_READ_ONLY, VX_MEMORY_TYPE_HOST, VX_NOGAP_X); vx_imagepatch_addressing_t out_addr; vx_map_id out_id; void *out_ptr; rect.start_x = 0; rect.start_y = 0; rect.end_x = obj-&gt;output_image_width; rect.end_y = obj-&gt;output_image_height; vxMapImagePatch(obj-&gt;output_img[0], &amp;rect, 0, &amp;out_id, &amp;out_addr, &amp;out_ptr, VX_WRITE_ONLY, VX_MEMORY_TYPE_HOST, VX_NOGAP_X); unsigned char *pin = input_ptr; unsigned char *pout = out_ptr; yuv420_to_uyvy()static void yuv420_to_yuyv(unsigned char *d, unsigned char *s,int w, int h) &#123; unsigned char *y,*u,*v,*u2,*v2; int a, b; y = s; u = y + w * h; v = u + w * h / 4; for (b = h; b &gt; 0; b -= 2) &#123; u2 = u; v2 = v; for (a = w; a &gt; 0; a -= 2) &#123; *(d++) = *(y++); *(d++) = *(u++); *(d++) = *(y++); *(d++) = *(v++);&#125; u = u2; v = v2; for (a = w; a &gt; 0; a -= 2) &#123; *(d++) = *(y++); *(d++) = *(u++); *(d++) = *(y++); *(d++) = *(v++);&#125; &#125;&#125;static void yuv420_to_uyvy(unsigned char *d, unsigned char *s,int w, int h) &#123; unsigned char *y,*u,*v,*u2,*v2; int a, b; y = s; u = y + w * h; v = u + w * h / 4; for (b = h; b &gt; 0; b -= 2) &#123; u2 = u; v2 = v; for (a = w; a &gt; 0; a -= 2) &#123; *(d++) = *(u++); *(d++) = *(y++); *(d++) = *(v++); *(d++) = *(y++); &#125; u = u2; v = v2; for (a = w; a &gt; 0; a -= 2) &#123; *(d++) = *(u++); *(d++) = *(y++); *(d++) = *(v++); *(d++) = *(y++); &#125; &#125;&#125;static void yuv420_to_yuyv(unsigned char *d, unsigned char *s,int w, int h) &#123; unsigned char *y,*u,*v,*u2,*v2; int a, b; y = s; u = y + w * h; v = u + w * h / 4; for (b = h; b &gt; 0; b -= 2) &#123; u2 = u; v2 = v; for (a = w; a &gt; 0; a -= 2) &#123; *(d++) = *(y++); *(d++) = *(u++); *(d++) = *(y++); *(d++) = *(v++);&#125; u = u2; v = v2; for (a = w; a &gt; 0; a -= 2) &#123; *(d++) = *(y++); *(d++) = *(u++); *(d++) = *(y++); *(d++) = *(v++);&#125; &#125;&#125;/* NOT VERIFIED *//* w must be a multiple of 8 ! */static void y41p_to_yuyv(unsigned char *d, unsigned char *s,int w, int h) &#123; int i; for(i=w*h;i&gt;0;i-=8,s+=12,d+=16) &#123; d[5]=d[1]=s[0]; d[0]=s[1]; d[7]=d[3]=s[2]; d[2]=s[3]; d[9]=d[13]=s[4]; d[4]=s[5]; d[11]=d[15]=s[6]; d[6]=s[7]; d[8]=s[8]; d[10]=s[9]; d[12]=s[10]; d[14]=s[11]; &#125;&#125;/* NOT VERIFIED */static void yuyv_to_y41p(unsigned char *d, unsigned char *s,int w, int h) &#123; int i; for(i=w*h;i&gt;0;i-=8,s+=16,d+=12) &#123; d[0]=s[1]; d[1]=s[0]; d[2]=s[3]; d[3]=s[2]; d[4]=s[9]; d[5]=s[4]; d[6]=s[11]; d[7]=s[6]; d[8]=s[8]; d[9]=s[10]; d[10]=s[12]; d[11]=s[14]; &#125; &#125;static void y410_to_y420(unsigned char *d, unsigned char *s,int w, int h) &#123; int t=w*h, i, x, y, w4=w/4; fast_memcpy(d, s, t); s+=t; d+=t; for(i=2;i&gt;0;i--) for(y=h;y&gt;0;y-=4) &#123; unsigned char *s0=s; for(x=w4;x&gt;0;x--) &#123; *(d++)=*s; *(d++)=*(s++); &#125; s=s0; for(x=w4;x&gt;0;x--) &#123; *(d++)=*s; *(d++)=*(s++); &#125; &#125;&#125;static void y420_to_y410(unsigned char *d, unsigned char *s,int w, int h) &#123; int i, t=w*h, x, y, w4=w/4; fast_memcpy(d, s, t); s+=t; d+=t; for(i=2;i&gt;0;i--) for(y=h;y&gt;0;y-=4) &#123; for(x=w4;x&gt;0;x--) &#123; *(d++)=*s; s+=2; &#125; s+=2*w4;; &#125;&#125;static void yuyv_to_yuv422p (unsigned char *d, unsigned char *s, int w, int h) &#123; int a, b; unsigned char *y, *u, *v; y = d; u = y + w * h; v = u + w * h / 2; for (a = h; a &gt; 0; a--) for (b = w; b &gt; 0; b -= 2) &#123; *(y++) = *(s++); *(u++) = *(s++); *(y++) = *(s++); *(v++) = *(s++); &#125;&#125;static void yuv422p_to_yuyv(unsigned char *d, unsigned char *s,int w, int h) &#123; unsigned char *y,*u,*v; int a, b; y = s; u = y + w * h; v = u + w * h / 2; for (b = h; b &gt; 0; b --) for (a = w; a &gt; 0; a -= 2) &#123; *(d++) = *(y++); *(d++) = *(u++); *(d++) = *(y++); *(d++) = *(v++);&#125;&#125;static void yuv411p_to_yuv422p (unsigned char *d, unsigned char *s, int w, int h) &#123; int i, t=w*h; fast_memcpy(d, s, t); d+=t; s+=t; for(i=t/2;i&gt;0;i--) &#123; *(d++)=*s; *(d++)=*(s++); &#125;&#125;static void yuv422p_to_yuv411p(unsigned char *d, unsigned char *s,int w, int h) &#123; int i, t=w*h; fast_memcpy(d, s, t); d+=t; s+=t; for(i=t/2;i&gt;0;i--) &#123; *(d++)=*s; s+=2; &#125;&#125;/* NOT VERIFIED */static void nv12_to_yuv420 (unsigned char *d, unsigned char *s, int w, int h) &#123; int i, t=w*h; unsigned char *y, *u, *v; y = d; u = y + t; v = u + t / 4; fast_memcpy(d, s, t); s += t; for(i=t/4;i&gt;0;i--) &#123; *(u++)=*(s++); *(v++)=*(s++); &#125;&#125;/* NOT VERIFIED */static void yuv420_to_nv12(unsigned char *d, unsigned char *s,int w, int h) &#123; int i, t=w*h; unsigned char *y,*u,*v; y = s; u = y + t; v = u + t / 4; fast_memcpy(d, s, t); d += t; for(i=t/4;i&gt;0;i--) &#123; *(d++)=*(u++); *(d++)=*(v++); &#125;&#125;/******** RGB to YUV functions **********/#ifdef WORDS_BIGENDIAN#define RGBDO &#123;s++; r=*(s++); g=*(s++); b=(*s++);&#125;#else#define RGBDO &#123;b=(*s++); g=*(s++); r=*(s++); s++;&#125;#endif#define Y(r,g,b) (((16829*r+31913*g+6416*b)&gt;&gt;16)+16)#define U(r,g,b) (((-9750*r-19148*g+28898*b)&gt;&gt;16)+128)#define V(r,g,b) (((28898*r-24199*g-4699*b)&gt;&gt;16)+128)static void rgb32_to_yuv420(unsigned char *d, unsigned char *s, int w, int h) &#123; int aa, bb; unsigned char *y, *u, *v, r, g, b; y = d; u = y + w * h; v = u + w * h / 4; for (aa = h; aa &gt; 0; aa -= 2) &#123; for (bb = w; bb &gt; 0; bb -= 2) &#123; RGBDO; *(y++)=Y(r,g,b); *(u++)=U(r,g,b); RGBDO; *(y++)=Y(r,g,b); &#125; for (bb = w; bb &gt; 0; bb -= 2) &#123; RGBDO; *(y++)=Y(r,g,b); RGBDO; *(y++)=Y(r,g,b); *(v++)=V(r,g,b); &#125; &#125;&#125;static void rgb32_to_yuyv(unsigned char *d, unsigned char *s, int w, int h) &#123; int i; for(i=w*h; i&gt;0;i-=2,s+=8,d+=4) &#123; unsigned char r,g,b;#ifdef WORDS_BIGENDIAN r=s[1]; g=s[2]; b=s[3]; #else b=s[0]; g=s[1]; r=s[2]; #endif d[0] = Y(r,g,b); d[1] = U(r,g,b);#ifdef WORDS_BIGENDIAN r=s[5]; g=s[6]; b=s[7]; #else b=s[4]; g=s[5]; r=s[6];#endif d[2] = Y(r,g,b); d[3] = V(r,g,b); &#125;&#125;static void rgb24_to_yuyv(unsigned char *d, unsigned char *s, int w, int h) &#123; int i; for(i=w*h; i&gt;0;i-=2,s+=6,d+=4) &#123; unsigned char r,g,b;#ifdef WORDS_BIGENDIAN r=s[0]; g=s[1]; b=s[2];#else b=s[0]; g=s[1]; r=s[2]; #endif d[0] = Y(r,g,b); d[1] = U(r,g,b);#ifdef WORDS_BIGENDIAN r=s[3]; g=s[4]; b=s[5]; #else b=s[3]; g=s[4]; r=s[5];#endif d[2] = Y(r,g,b); d[3] = V(r,g,b); &#125;&#125;/****** YUV to RGB functions *******/#define sat(x,max) if(x&lt;0) x=0; if(x&gt;max) x=max;static inline void pix_yuv_to_rgb(unsigned char y, unsigned char u, unsigned char v, unsigned char *r, unsigned char *g, unsigned char *b) &#123; int y2,r2,g2,b2; y2=76309*y; r2=(-14556884+y2+104187*v)&gt;&gt;16; sat(r2,255); *r=r2; g2=(8842838+y2-25564*u-53060*v)&gt;&gt;16; sat(g2,255); *g=g2; b2=(-18076354+y2+131683*u)&gt;&gt;16; sat(b2,255); *b=b2;&#125;#ifdef WORDS_BIGENDIAN#define RGBDO2 &#123;pix_yuv_to_rgb(*y,*u,*v,&amp;d[1],&amp;d[2],&amp;d[3]);&#125;#else#define RGBDO2 &#123;pix_yuv_to_rgb(*y,*u,*v,&amp;d[2],&amp;d[1],&amp;d[0]);&#125;#endifstatic void yuv420_to_rgb32(unsigned char *d, unsigned char *s, int w, int h) &#123; unsigned char *y, *u, *v, *u2, *v2; int a,b; y = s; u = y + w * h; v = u + w * h / 4; for (a = h; a &gt; 0; a -= 2) &#123; u2 = u; v2 = v; for (b = w; b &gt; 0; b -= 2) &#123; RGBDO2; y++; d+=4; RGBDO2; y++; u++; v++; d+=4; &#125; u = u2; v = v2; for (b = w; b &gt; 0; b -= 2) &#123; RGBDO2; y++; d+=4; RGBDO2; y++; u++; v++; d+=4; &#125; &#125;&#125;static void yuyv_to_rgb32(unsigned char *d, unsigned char *s, int width, int height) &#123; int i; for(i=width*height;i&gt;0;i-=2,s+=4,d+=8) &#123;#ifdef WORDS_BIGENDIAN pix_yuv_to_rgb(s[0],s[1],s[3],&amp;d[1],&amp;d[2],&amp;d[3]); pix_yuv_to_rgb(s[2],s[1],s[3],&amp;d[5],&amp;d[6],&amp;d[7]);#else pix_yuv_to_rgb(s[0],s[1],s[3],&amp;d[2],&amp;d[1],&amp;d[0]); pix_yuv_to_rgb(s[2],s[1],s[3],&amp;d[6],&amp;d[5],&amp;d[4]);#endif &#125;&#125;/** end YUV to RGB functions **//****************************************************** **** The exported functions ********************************************/int size_img(video_fmt f, int width, int height) &#123; /* width should be a multiple of 8 to be sure.... and height a multiple of 2 */ switch(f) &#123; case VIDEO_GRAY1: case VIDEO_GRAY1X: return ((width+31)/32)*4*height; case VIDEO_GRAY4: case VIDEO_RGB03: case VIDEO_RGB04b: return width*height; case VIDEO_GRAY8: case VIDEO_RGB08: case VIDEO_RGB08b: case VIDEO_HI240: return width*height; case VIDEO_RGB15X: case VIDEO_RGB15: case VIDEO_RGB16X: case VIDEO_RGB16: return width*height*2; case VIDEO_RGB24: case VIDEO_RGB24X: case VIDEO_RGB24B: return width*height*3; case VIDEO_RGB32: case VIDEO_RGB32P: case VIDEO_RGB32X: case VIDEO_RGB32PX: case VIDEO_RGB32B: return width*height*4; case VIDEO_UYVY: case VIDEO_YUYV : case VIDEO_YUV422P: return width*height*2; case VIDEO_Y41P: case VIDEO_YUV420: case VIDEO_YVU420: case VIDEO_YUV411P: case VIDEO_NV12: return width*height*3/2; case VIDEO_YUV410: case VIDEO_YVU410: return width*height*5/4; case MAX_VIDEO_FMT: case VIDEO_NOFORMAT: fprintf(stderr,&quot;SHOULD NOT HAPPEN\\n&quot;); exit(1); &#125; return 0;&#125;void* convert1(char *src, video_fmt f_src, video_fmt f_dest, int width, int height) &#123; static void *bufs[MAX_VIDEO_FMT]; if(debug&gt;=2) fprintf(stderr, &quot;convert1 %s -&gt; %s %dx%d\\n&quot;, int_to_str (f_src,video_fmt_names), int_to_str (f_dest,video_fmt_names), width, height); if(f_src==f_dest) return src; /* during the pipe it is constant in fact... */ bufs[f_dest]=realloc(bufs[f_dest],size_img(f_dest,width,height)); convert2(src,f_src,bufs[f_dest],f_dest,width,height); return bufs[f_dest];&#125;typedef void (*convertf) (unsigned char *d, unsigned char *s, int w, int h);typedef struct &#123;convertf conv;video_fmt f_src; video_fmt f_dst; int cost;&#125; convertf2;static convertf2 convs[]= &#123; &#123;gray1_to_gray8, VIDEO_GRAY1, VIDEO_GRAY8, 20&#125;, &#123;gray8_to_gray1, VIDEO_GRAY8, VIDEO_GRAY1, 40&#125;, &#123;gray4_to_gray8, VIDEO_GRAY4, VIDEO_GRAY8, 20&#125;, &#123;gray8_to_gray4, VIDEO_GRAY8, VIDEO_GRAY4, 40&#125;, &#123;rgb3_to_rgb32, VIDEO_RGB03, VIDEO_RGB32, 20&#125;, &#123;rgb32_to_rgb3, VIDEO_RGB32, VIDEO_RGB03, 40&#125;, &#123;rgb15_to_rgb32, VIDEO_RGB15, VIDEO_RGB32, 10&#125;, &#123;rgb32_to_rgb15, VIDEO_RGB32, VIDEO_RGB15, 15&#125;, &#123;rgb16_to_rgb32, VIDEO_RGB16, VIDEO_RGB32, 10&#125;, &#123;rgb32_to_rgb16, VIDEO_RGB32, VIDEO_RGB16, 15&#125;, &#123;rgb24_to_rgb32, VIDEO_RGB24, VIDEO_RGB32, 5&#125;, &#123;rgb32_to_rgb24, VIDEO_RGB32, VIDEO_RGB24, 5&#125;, &#123;yuv420_to_gray8, VIDEO_YUV420, VIDEO_GRAY8, 200&#125;, //too much info lost &#123;gray8_to_yuv420, VIDEO_GRAY8, VIDEO_YUV420, 4&#125;, &#123;hi240_to_rgb32, VIDEO_HI240, VIDEO_RGB32, 20&#125;, &#123;rgb32_to_hi240, VIDEO_RGB32, VIDEO_HI240, 40&#125;, //too much info lost &#123;rgb8_to_rgb32, VIDEO_RGB08, VIDEO_RGB32, 10&#125;, &#123;rgb32_to_rgb8, VIDEO_RGB32, VIDEO_RGB08, 38&#125;, //too much info lost &#123;rgb8b_to_rgb32, VIDEO_RGB08b, VIDEO_RGB32, 10&#125;, &#123;rgb32_to_rgb8b, VIDEO_RGB32, VIDEO_RGB08b, 38&#125;, &#123;rgb4b_to_rgb32, VIDEO_RGB04b, VIDEO_RGB32, 20&#125;, &#123;rgb32_to_rgb4b, VIDEO_RGB32, VIDEO_RGB04b, 40&#125;, &#123;yuyv_to_yuv420, VIDEO_YUYV, VIDEO_YUV420, 5&#125;, &#123;yuv420_to_yuyv, VIDEO_YUV420, VIDEO_YUYV, 5&#125;, &#123;rgb32_to_yuv420, VIDEO_RGB32, VIDEO_YUV420, 32&#125;, &#123;rgb24_to_yuyv, VIDEO_RGB24, VIDEO_YUYV, 30&#125;, &#123;rgb32_to_yuyv, VIDEO_RGB32, VIDEO_YUYV, 31&#125;, &#123;yuv420_to_rgb32, VIDEO_YUV420, VIDEO_RGB32, 31&#125;, &#123;yuyv_to_rgb32, VIDEO_YUYV, VIDEO_RGB32, 32&#125;, &#123;yvu420_yuv420, VIDEO_YVU420, VIDEO_YUV420, 4&#125;, &#123;yvu420_yuv420, VIDEO_YUV420, VIDEO_YVU420, 4&#125;, &#123;rgb32_rgb32b, VIDEO_RGB32, VIDEO_RGB32B, 4&#125;, &#123;rgb32_rgb32b, VIDEO_RGB32B, VIDEO_RGB32, 4&#125;, &#123;rgb24_rgb24b, VIDEO_RGB24, VIDEO_RGB24B, 4&#125;, &#123;rgb24_rgb24b, VIDEO_RGB24B, VIDEO_RGB24, 4&#125;, &#123;swap16bpp, VIDEO_YUYV, VIDEO_UYVY, 6&#125;, &#123;swap16bpp, VIDEO_UYVY, VIDEO_YUYV, 6&#125;, &#123;swap16bpp, VIDEO_RGB16, VIDEO_RGB16X, 6&#125;, &#123;swap16bpp, VIDEO_RGB16X, VIDEO_RGB16, 6&#125;, &#123;swap16bpp, VIDEO_RGB15, VIDEO_RGB15X, 6&#125;, &#123;swap16bpp, VIDEO_RGB15X, VIDEO_RGB15, 6&#125;, &#123;swap24bpp, VIDEO_RGB24, VIDEO_RGB24X, 6&#125;, &#123;swap24bpp, VIDEO_RGB24X, VIDEO_RGB24, 6&#125;, &#123;swap32bpp, VIDEO_RGB32, VIDEO_RGB32X, 6&#125;, &#123;swap32bpp, VIDEO_RGB32X, VIDEO_RGB32, 6&#125;, &#123;swap32bpp, VIDEO_RGB32P, VIDEO_RGB32PX, 6&#125;, &#123;swap32bpp, VIDEO_RGB32PX,VIDEO_RGB32P, 6&#125;, &#123;rgb24_to_rgb32, VIDEO_RGB24X, VIDEO_RGB32PX, 5&#125;, &#123;rgb32_to_rgb24, VIDEO_RGB32PX,VIDEO_RGB24X, 5&#125;, &#123;swap1bpp32, VIDEO_GRAY1, VIDEO_GRAY1X, 5&#125;, &#123;swap1bpp32, VIDEO_GRAY1X, VIDEO_GRAY1, 5&#125;, &#123;y41p_to_yuyv, VIDEO_Y41P, VIDEO_YUYV, 10&#125;, &#123;yuyv_to_y41p, VIDEO_YUYV, VIDEO_Y41P, 10&#125;, &#123;y410_to_y420, VIDEO_YUV410, VIDEO_YUV420, 8&#125;, &#123;y420_to_y410, VIDEO_YUV420, VIDEO_YUV410, 8&#125;, &#123;y410_to_y420, VIDEO_YVU410, VIDEO_YVU420, 8&#125;, &#123;y420_to_y410, VIDEO_YVU420, VIDEO_YVU410, 8&#125;, &#123;yuyv_to_yuv422p, VIDEO_YUYV, VIDEO_YUV422P, 8&#125;, &#123;yuv422p_to_yuyv, VIDEO_YUV422P,VIDEO_YUYV, 8&#125;, &#123;yuv411p_to_yuv422p, VIDEO_YUV411P, VIDEO_YUV422P, 8&#125;, &#123;yuv422p_to_yuv411p, VIDEO_YUV422P,VIDEO_YUV411P, 8&#125;, &#123;nv12_to_yuv420, VIDEO_NV12, VIDEO_YUV420, 5&#125;, &#123;yuv420_to_nv12, VIDEO_YUV420, VIDEO_NV12, 5&#125;, &#123;NULL, 0, 0, 100&#125;&#125;;static convertf2 **firstconv=NULL;/* compute the best intermediate format by Dijkstra&#x27;s algorithm */static void initfirstconv(void) &#123; /* direct cannot be put in cost_tab because it could be possible that the direct link is not the fastest (probably by a fault in the costs...) */ int direct[MAX_VIDEO_FMT][MAX_VIDEO_FMT]; int cost_tab[MAX_VIDEO_FMT][MAX_VIDEO_FMT],i,j,dest; convertf2 *c,*c2; firstconv=calloc(MAX_VIDEO_FMT*MAX_VIDEO_FMT,sizeof(convertf2*)); for(i=1;i&lt;MAX_VIDEO_FMT;i++) for(j=1;j&lt;MAX_VIDEO_FMT;j++) &#123; direct[i][j]=-1; if(i==j) cost_tab[i][j]=0; else cost_tab[i][j]=-1; &#125; c=convs;while(c-&gt;conv) &#123;direct[c-&gt;f_src][c-&gt;f_dst]=c-&gt;cost;c++;&#125; for(dest=1;dest&lt;MAX_VIDEO_FMT;dest++) &#123; int i0,j0; do &#123; int m=10000000; i0=j0=-1; for(i=1;i&lt;MAX_VIDEO_FMT;i++) if(cost_tab[i][dest]!=-1) for(j=1;j&lt;MAX_VIDEO_FMT;j++) if(direct[j][i]!=-1 &amp;&amp; cost_tab[j][dest]==-1 &amp;&amp; direct[j][i]+cost_tab[i][dest]&lt;m) &#123;m=direct[j][i]+cost_tab[i][dest]; i0=i; j0=j;&#125; if(i0!=-1) &#123; cost_tab[j0][dest]=m; c2=convs; while(c2-&gt;f_src!=j0 || c2-&gt;f_dst!=i0) c2++; firstconv[j0+dest*MAX_VIDEO_FMT]=c2; &#125; &#125; while(i0!=-1); &#125; if(debug&gt;=2) &#123; fprintf(stderr, &quot;conversion costs:\\n&quot;); for(i=1;i&lt;MAX_VIDEO_FMT;i++) for(j=1;j&lt;MAX_VIDEO_FMT;j++) fprintf(stderr, &quot;%s -&gt; %s: %d (by %s)\\n&quot;, int_to_str(i, video_fmt_names), int_to_str(j, video_fmt_names), cost_tab[i][j], firstconv[i+j*MAX_VIDEO_FMT]!=NULL ? int_to_str(firstconv[i+j*MAX_VIDEO_FMT]-&gt;f_dst, video_fmt_names):&quot;-&quot;); &#125;&#125;static int convert_cost(video_fmt f_src, video_fmt f_dest) &#123; convertf2 *c; if(f_src==f_dest) return 0; if(firstconv==NULL) initfirstconv(); c=firstconv[f_src+MAX_VIDEO_FMT*f_dest]; if(c==NULL) return 1000000; return c-&gt;cost+convert_cost(c-&gt;f_dst,f_dest);&#125;void convert2(char *src, video_fmt f_src, char *dest, video_fmt f_dest, int width, int height) &#123; int size; convertf2 *c; if(debug&gt;=2) &#123; fprintf(stderr, &quot;convert2 %s -&gt; %s %dx%d\\n&quot;, int_to_str (f_src,video_fmt_names), int_to_str (f_dest,video_fmt_names), width, height); &#125; size=size_img(f_src,width,height); if(f_src==f_dest) &#123; fast_memcpy(dest,src,size); return; &#125; if(firstconv==NULL) initfirstconv(); c=firstconv[f_src+MAX_VIDEO_FMT*f_dest]; if(c==NULL) &#123; fprintf(stderr, &quot;convert2 %s -&gt; %s not implemented\\n&quot;, int_to_str (f_src,video_fmt_names), int_to_str (f_dest,video_fmt_names)); //exit (1); return; &#125; if(c-&gt;f_dst==f_dest) c-&gt;conv((unsigned char*)dest, (unsigned char*)src, width, height); else &#123; void *mem=convert1(src, f_src, c-&gt;f_dst, width, height); convert2(mem, c-&gt;f_dst, dest, f_dest, width, height); &#125; return;&#125;/* takes an array of video_fmt */int setpreferred_list(video_fmt formats[], video_fmt prefered[]) &#123; int available[MAX_VIDEO_FMT], i; for(i=0;i&lt;MAX_VIDEO_FMT;i++) available[i]=0; for(i=0;formats[i]!=0;i++) available[formats[i]]=1; return setpreferred(available,prefered);&#125;/* takes an array of booleans */int setpreferred(int available[], video_fmt prefered[]) &#123; int i; video_fmt def=0; if(debug) fprintf(stderr, &quot;*** asked for prefered conversions ***\\n&quot;); for(i=1;i&lt;MAX_VIDEO_FMT;i++) if(available[i]) &#123;def=i; break;&#125; if(def==0) return 0; for(i=1;i&lt;MAX_VIDEO_FMT;i++) &#123; int cost=100000,j; prefered[i]=def; // unneeded if there are all the conversions for(j=1;j&lt;MAX_VIDEO_FMT;j++) if(available[j] &amp;&amp; convert_cost(j,i)&lt;cost) &#123; cost=convert_cost(j,i); prefered[i]=j; &#125; if(debug) fprintf(stderr,&quot;%s --&gt; %s\\n&quot;, int_to_str(i, video_fmt_names), int_to_str(prefered[i], video_fmt_names)); &#125; if(debug) fprintf(stderr, &quot;*** end prefered conversions ***\\n&quot;); return 1;&#125; 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"colorspace","slug":"技术分享/colorspace","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/colorspace/"}],"tags":[{"name":"Color","slug":"Color","permalink":"https://dllmayday.github.io/tags/Color/"}]},{"title":"gcc编译时嵌入资源文件","slug":"gccwithresource","date":"2024-02-20T08:32:12.000Z","updated":"2025-08-18T09:22:36.256Z","comments":true,"path":"2024/02/20/gccwithresource/","permalink":"https://dllmayday.github.io/2024/02/20/gccwithresource/","excerpt":"需求:程序在加载运行时有时候需要加载某一目录下的某些文件，而这些文件比较敏感，一旦被用户意外修改有可能导致程序运行出错甚至无法运行。为了避免这种情况的出现同时方便应用程序的移植，我们可以在编译应用程序的时候把这些资源文件一起编译进去，这样程序运行的时候就不会依赖目录下的文件了。 #1. CMKAE 编译嵌入使用github CMRC 参考github pbr_model_viewer工程#2. bin2c bin2h 将资源文件转为字节数组#3. GCC 编译嵌入","text":"需求:程序在加载运行时有时候需要加载某一目录下的某些文件，而这些文件比较敏感，一旦被用户意外修改有可能导致程序运行出错甚至无法运行。为了避免这种情况的出现同时方便应用程序的移植，我们可以在编译应用程序的时候把这些资源文件一起编译进去，这样程序运行的时候就不会依赖目录下的文件了。 #1. CMKAE 编译嵌入使用github CMRC 参考github pbr_model_viewer工程#2. bin2c bin2h 将资源文件转为字节数组#3. GCC 编译嵌入 准备工作:编写一个helloworld程序: 123456#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;hello world\\n&quot;); return 0;&#125; 编译:gcc helloworld.c -o helloworld.o查看helloworld.o的文件格式与计算机体系架构:objdump -x helloworld.o在这里插入图片描述从上图可以看出文件格式与计算机体系架构分别为:文件格式：elf64-tradlittlemips体系结构：mips:isa64r2 两个文件:1、test.txt: 1This file is named ning.txt 2、main.c 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;extern char _binary_ning_txt_start;extern char _binary_ning_txt_end;int main(void)&#123; printf(&quot;hello world\\n&quot;); char *p = &amp;_binary_ning_txt_start; while(p != &amp;_binary_ning_txt_end) putchar(*p++); return 0;&#125; 从上面的main.c可以看到，引入了两个外部变量extern char _binary_ning_txt_start;extern char _binary_ning_txt_end; 这两个变量是将文件test.txt编译成二进制文件的时候生成的，具体的编译指令如下: 1objcopy --input binary --output elf64-tradlittlemips --binary-architecture mips:isa64r2 ning.txt ning.o 说明:–input binary ： 输入文件以二进制–output elf64-tradlittlemips：输出elf64-tradlittlemips格式文件–binary-architecture mips:isa64r2：该输出文件跑在mips:isa64r2体系架构上，这个擦拿书可参考资料https://sourceware.org/binutils/docs/binutils/objcopy.html的描述: –binary-architecture&#x3D;bfdarchUseful when transforming a architecture-less input file into an object file.In this case the output architecture can be set to bfdarch. This option willbe ignored if the input file has a known bfdarch. You can access this binary data inside a program by referencing the special symbols that are created by the conversion process. These symbols are called _binary_objfile_start, _binary_objfile_end and _binary_objfile_size. e.g. you can transform a picture file into an object file and then access it in your code using these symbols. 后面两个参数的选择是根据前面的准备工作中得到的文件格式与计算机体系架构确定的，然后使用objdump工具查看文件ning.o: 这个就是main.c中引用的外部变量的由来，现在把两个文件编译在一起: 1gcc main.c test.o -o xxxning 运行: ./xxxning 参考文献:1、https://stackoverflow.com/questions/4864866/c-c-with-gcc-statically-add-resource-files-to-executable-library2、https://sourceware.org/binutils/docs/binutils/objcopy.html————————————————原文链接：https://blog.csdn.net/u014780310/article/details/113770587 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"实用技巧","slug":"技术分享/实用技巧","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"CMRC","slug":"CMRC","permalink":"https://dllmayday.github.io/tags/CMRC/"}]},{"title":"tar包加密","slug":"tarpackagelock","date":"2024-02-20T08:28:12.000Z","updated":"2025-08-18T09:22:36.263Z","comments":true,"path":"2024/02/20/tarpackagelock/","permalink":"https://dllmayday.github.io/2024/02/20/tarpackagelock/","excerpt":"","text":"打包&amp;加密1tar -zcvf - cc | openssl des3 -salt -k [passwd] | dd of=[package_name].des3 解密&amp;解包1dd if=[package_name].des3 | openssl des3 -d -k [passwd] | tar zxf - 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"实用技巧","slug":"技术分享/实用技巧","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"tar","slug":"tar","permalink":"https://dllmayday.github.io/tags/tar/"}]},{"title":"几何变换","slug":"geometrytranform","date":"2024-02-20T08:09:32.000Z","updated":"2025-08-18T09:22:36.256Z","comments":true,"path":"2024/02/20/geometrytranform/","permalink":"https://dllmayday.github.io/2024/02/20/geometrytranform/","excerpt":"图像的几何变换主要包括：平移、旋转、缩放、剪切、仿射、透视等。图像的几何变换主要分为：刚性变换、相似变换、仿射变换和透视变换（也称为投影变换）。刚性变换：平移、旋转；相似变换：缩放、剪切；仿射变换：从一个二维坐标系变换到另一个二维坐标系的过程，属于线性变换。通过已知3对坐标点便可求取变换矩阵。透视变换：从二维坐标系变换到三维坐标系，在从三维坐标系投影到二维平面，属于非线性变换。通过已知4对坐标点便可求取变换矩阵。","text":"图像的几何变换主要包括：平移、旋转、缩放、剪切、仿射、透视等。图像的几何变换主要分为：刚性变换、相似变换、仿射变换和透视变换（也称为投影变换）。刚性变换：平移、旋转；相似变换：缩放、剪切；仿射变换：从一个二维坐标系变换到另一个二维坐标系的过程，属于线性变换。通过已知3对坐标点便可求取变换矩阵。透视变换：从二维坐标系变换到三维坐标系，在从三维坐标系投影到二维平面，属于非线性变换。通过已知4对坐标点便可求取变换矩阵。 一个集合 X XX 的仿射变换为： f(x)&#x3D;Ax+b,x∈X 它的几何意义是对一个图形进行：缩放（Scale）、平移(translate)、旋转(rotate)、反射（reflection, 对图形照镜子）、错切(shear mapping，感觉像是一个图形的倒影) 或者它们的任意组合 （Ax 加上向量 b，相当于对Ax平移） 维基百科中的一个图很好诠释了各种仿射变换： 仿射变换中集合中的一些性质保持不变：（1）凸性（2）共线性：若几个点变换前在一条线上，则仿射变换后仍然在一条线上（3）平行性：若两条线变换前平行，则变换后仍然平行（4）共线比例不变性：变换前一条线上两条线段的比例，在变换后比例仍然步 注：所有的三角形都能通过仿射变化为其他三角形，所有平行四边形也能仿射变换为另一个平行四边形。 版权信息","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"数学","slug":"技术分享/数学","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"几何","slug":"几何","permalink":"https://dllmayday.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"Hexo使用技巧","slug":"hexo/HexoGuide","date":"2024-02-05T06:42:53.000Z","updated":"2025-08-18T09:22:36.258Z","comments":true,"path":"2024/02/05/hexo/HexoGuide/","permalink":"https://dllmayday.github.io/2024/02/05/hexo/HexoGuide/","excerpt":"使用技巧修改站点网页分享链接为github站点url2024-02-01 15:31:07修改Hexo工程根目录下_config.yml文件中url为 GitHub Page URL 1url: https://dllmayday.github.io/","text":"使用技巧修改站点网页分享链接为github站点url2024-02-01 15:31:07修改Hexo工程根目录下_config.yml文件中url为 GitHub Page URL 1url: https://dllmayday.github.io/ 自定义文章生成模板修改scaffolds目录下post.md（page&#x2F;draft可根据平时用哪个创建进行修改，一般用post创建文章）可按双斜杠后对应标签说明进行添加(post保存时需删除注释文字) 12345678910111213141516171819202122232425262728---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;permalink: //文章显示连接categories: //文章匪类目录tags: //文章标签，可多个，用，隔开description: //文章描述image: //自定义的文章摘要图片，只在页面展示，文章内消失copyright: true //增加底部的版权信息（需要配置）--- //首页文章展示缩略图&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;0x00 前言&lt;!--more--&gt;//正文## 0x01 ## 0x02## 0x03## 0x04&lt;hr /&gt;版权信息 父子分类new post front-matter按如下添加技术分享为父分类Hexo为子分类 123categories: - 技术分享- Hexo 页面显示如下: 隐藏网页底部 powered By Hexo去对应使用主题themes&#x2F;landscape&#x2F;layout&#x2F;_partial&#x2F;查找文件footer.ejs，删除powered_by所在行行 使用github issue存放评论","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Hexo","slug":"技术分享/Hexo","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://dllmayday.github.io/tags/Hexo/"}]},{"title":"Hexo快速入门","slug":"hexo/LearnHexo","date":"2024-02-01T07:31:07.000Z","updated":"2025-08-18T09:22:36.259Z","comments":true,"path":"2024/02/01/hexo/LearnHexo/","permalink":"https://dllmayday.github.io/2024/02/01/hexo/LearnHexo/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; Create a new page12345678910$ hexo new page &quot;My New Page&quot;More info: [Writing](https://hexo.io/docs/writing.html)### Run server``` bash$ hexo server #或缩写$ hexo s More info: Server Generate static files123$ hexo generate#或缩写$ hexo g More info: Generating Deploy to remote sites123$ hexo deploy#或缩写$ hexo d More info: Deployment Remove generated files and cache.1$ hexo clean","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"Hexo","slug":"技术分享/Hexo","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://dllmayday.github.io/tags/Hexo/"}]}],"categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"dbus","slug":"技术分享/dbus","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/dbus/"},{"name":"Cmake","slug":"技术分享/Cmake","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Cmake/"},{"name":"virtual-machine","slug":"技术分享/virtual-machine","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/virtual-machine/"},{"name":"Docker","slug":"技术分享/Docker","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Docker/"},{"name":"Debug","slug":"技术分享/Debug","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Debug/"},{"name":"交叉编译","slug":"技术分享/交叉编译","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"实用技巧","slug":"技术分享/实用技巧","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"数学","slug":"技术分享/数学","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E6%95%B0%E5%AD%A6/"},{"name":"Linux","slug":"技术分享/Linux","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Linux/"},{"name":"Visual Studio","slug":"技术分享/Visual-Studio","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Visual-Studio/"},{"name":"GLOG","slug":"技术分享/GLOG","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/GLOG/"},{"name":"colorspace","slug":"技术分享/colorspace","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/colorspace/"},{"name":"Hexo","slug":"技术分享/Hexo","permalink":"https://dllmayday.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/Hexo/"}],"tags":[{"name":"dbus","slug":"dbus","permalink":"https://dllmayday.github.io/tags/dbus/"},{"name":"Cmake","slug":"Cmake","permalink":"https://dllmayday.github.io/tags/Cmake/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://dllmayday.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Docker","slug":"Docker","permalink":"https://dllmayday.github.io/tags/Docker/"},{"name":"Debug","slug":"Debug","permalink":"https://dllmayday.github.io/tags/Debug/"},{"name":"交叉编译","slug":"交叉编译","permalink":"https://dllmayday.github.io/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"欧拉角","slug":"欧拉角","permalink":"https://dllmayday.github.io/tags/%E6%AC%A7%E6%8B%89%E8%A7%92/"},{"name":"GLM","slug":"GLM","permalink":"https://dllmayday.github.io/tags/GLM/"},{"name":"环境变量","slug":"环境变量","permalink":"https://dllmayday.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"cmd","slug":"cmd","permalink":"https://dllmayday.github.io/tags/cmd/"},{"name":"dependents","slug":"dependents","permalink":"https://dllmayday.github.io/tags/dependents/"},{"name":"VisualStudio","slug":"VisualStudio","permalink":"https://dllmayday.github.io/tags/VisualStudio/"},{"name":"encoding","slug":"encoding","permalink":"https://dllmayday.github.io/tags/encoding/"},{"name":"WSL","slug":"WSL","permalink":"https://dllmayday.github.io/tags/WSL/"},{"name":"glog","slug":"glog","permalink":"https://dllmayday.github.io/tags/glog/"},{"name":"Linux","slug":"Linux","permalink":"https://dllmayday.github.io/tags/Linux/"},{"name":"Beyond Compare","slug":"Beyond-Compare","permalink":"https://dllmayday.github.io/tags/Beyond-Compare/"},{"name":"vmware","slug":"vmware","permalink":"https://dllmayday.github.io/tags/vmware/"},{"name":"Color","slug":"Color","permalink":"https://dllmayday.github.io/tags/Color/"},{"name":"CMRC","slug":"CMRC","permalink":"https://dllmayday.github.io/tags/CMRC/"},{"name":"tar","slug":"tar","permalink":"https://dllmayday.github.io/tags/tar/"},{"name":"几何","slug":"几何","permalink":"https://dllmayday.github.io/tags/%E5%87%A0%E4%BD%95/"},{"name":"Hexo","slug":"Hexo","permalink":"https://dllmayday.github.io/tags/Hexo/"}]}